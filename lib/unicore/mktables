#!/usr/bin/perl -w

## !!!!!!!!!!!!!!       IF YOU MODIFY THIS FILE       !!!!!!!!!!!!!!!!!!!!!!!!!
## Any files created or read by this program should be listed in 'mktables.lst'

require 5.008;	# Needs pack "U". Probably safest to run on 5.8.x
use strict;
use warnings;
use Carp;
use Cwd;
use File::Spec;
$|=1;

##
## mktables -- create the runtime Perl Unicode files (lib/unicore/*.pl,
## lib/unicore/lib/*/*.pl), and lib/unicore/To/*.pl
## from the Unicode database files (lib/unicore/*.txt).
##
# This program uses inputs published by the Unicode Consortium.  These can
# change incompatibly between releases without the Perl maintainers realizing
# it.  Therefore this program is now designed to try to flag these.  It looks
# at the directory where the inputs are and flags any unrecognized files.  It
# keeps track of all the properties in those files, and flags any that it
# doesn't know how to handle.  It also flags any input lines that don't match
# the expected syntax, among other checks.
# It is also designed so if a new input file matches one of the known
# templates, one just needs to add it to a table to have it processed.
#
# The program currently relies on syntax introduced in Unicode Version 5.0.
# With a little work, it could handle versions back to 3.2.
#
# The structure of this file is first these introductory comments, then
# data structures likely to be of external interest, then code to handle
# input parameters, then more data structures and subroutine and package
# definitions, then the small actual loop to process the input files and
# finish up, then a __DATA__ section

# Summary of how it works:

my $LastUnicodeCodepointString = "10FFFF"; # As of Unicode 5.1.
my $LastUnicodeCodepoint = hex($LastUnicodeCodepointString);

# This matches the beginning of the line in the Unicode db files that give the
# defaults for code points not listed in the file
my $missing_defaults_prefix = qr/^#\s+\@missing:\s+0000\.\.$LastUnicodeCodepointString\s*;/;

# The following are property names and property value names that conflict
# between Unicode and Perl.  The code will not allow Unicode aliases by these
# names, so programs wanting the Unicode version will have to use a different
# alias for them.  This table was generated by running this program, and
# looking at its error messages.  The error message will be in lower case, but
# the names here must match those in the respective Property Alias file.  This
# might need to be split in the future to separate the two files should Unicode
# or perl define new properties that need to be distinguished from property
# values

my %conflicting_property_names = (
    'Alpha' => 1,	    # Unicode alias for Alphabetic, a number of
			    # differences between the versions
    'cntrl' => 1,	    # Unicode alias for Control.  Unicode is Cc, perl 
			    # is all the C's except Cn.
    'digit' => 1,	    # Unicode alias for Decimal_Number, but are equal in
			    # 5.1
    'Lower' => 1, 	    # Unicode alias for Lowercase, a few diffs
    'punct' => 1,	    # Unicode alias for Punctuation, but are equal in 5.1
    'space' => 1,	    # Unicode alias for White_Space, but are equal in 5.1
    'Upper' => 1,	    # Unicode alias for Uppercase, a few diffs
);

# The following are property values that are listed as being valid but as of
# Unicode Version 5.1, no code point has them.  This structure is used to
# suppress error messages about their not being present.

my %extraneous_property_values = (
    'Canonical_Combining_Class' => 'Attached_Below_Left',
    'Joining_Type' => 'Left_Joining',
    'Script' => 'Katakana_Or_Hiragana',	# Unicode moved code points out of here
);

# Below are the properties that aren't fully accessible through the Perl core.
# In general, none of the string properties are accessible, as there is no Perl
# construct for any such property (where given the property name and a code
# point, it returns the value).  However, Perl has synonyms for some of the
# properties (like lc for Lowercase_Mapping), and most of the others can be
# accessed through library modules.
# Similarly for enumerated properites, but in these cases a code point can be
# tested against any given set of enumerations using a regular expression
# containing a \p{property: value} construct.
# All the binary (True or False) properties are considered to be fully
# accessible through regular expression property matching (\p{...}).
# Several properties are accessible through .pl files that this
# script creates (but which as of this writing aren't publicly documented).

# The following are properties that are in the files that we process, but we
# don't use them.  The reason is given by the comments unless it is a string
# property that perl doesn't handle, in which case the comment gives alternate
# access.

my @skipped_properties = (
    'FC_NFKC_Closure',	# But can use Unicode::Normalize
    'Grapheme_Link',	# Deprecated by Unicode
    'NFC_Quick_Check',	# But can access through Unicode::Normalize checkNFC
    'NFD_Quick_Check',	# But can access through Unicode::Normalize checkNFD
    'NFKC_Quick_Check',	# But can access through Unicode::Normalize checkNFKC
    'NFKD_Quick_Check',	# But can access through Unicode::Normalize checkNFKD
    'Other_Alphabetic',	# For internal Unicode use only
    'Other_Default_Ignorable_Code_Point',	# For internal Unicode use only
    'Other_Grapheme_Extend',	# For internal Unicode use only
    'Other_ID_Continue',	# For internal Unicode use only
    'Other_ID_Start',	# For internal Unicode use only
    'Other_Lowercase',	# For internal Unicode use only
    'Other_Math',	# For internal Unicode use only
    'Other_Uppercase',	# For internal Unicode use only
);

# Below are the other properties that aren't fully accessible through the Perl
# core.  The comments give the alternate accessibility

my @ignored_properties = (
    'Age',			# But \p{age:...} works
    'Bidi_Class',		# But can access through Unicode::UCD 'charinfo',
				# and \p{bc:...} works
    'Bidi_Mirroring_Glyph',	# Unimplemented
    'Block',			# But can access through
				# Unicode::UCD 'charblock', and \p{IsBLOCK}
				# works
    'Canonical_Combining_Class',    # But can access through
				# Unicode::UCD 'charinfo', and \p{ccc:...} works
    'Case_Folding',		# But can access through
				# Unicode::UCD 'casefold', and /RE/i works
    'Decomposition_Mapping',	# But can access through Unicode::UCD 'charinfo'
				# and furnished in Decomposition.pl
    'Decomposition_Type',	# But can access through Unicode::UCD 'charinfo'
				# and furnished in Decomposition.pl, and
				# \p{dt:...} works
    'East_Asian_Width',		# But \p{ea:...} works
    'General_Category',		# But can access through
				# Unicode::UCD 'charinfo', and /\p{IsCATEGORY}/
				# works
    'Grapheme_Cluster_Break',	# But \p{gcb:...} works
    'Hangul_Syllable_Type',	# But \p{hst:...} works
    'ISO_Comment',		# But can access through Unicode::UCD 'charinfo'
    'Jamo_Short_Name',		# But used in generating Name.pl
    'Joining_Group',		# But \p{jg:...} works
    'Joining_Type',		# But \p{jt:...} works
    'Line_Break',		# But \p{lb:...} works
    'Lowercase_Mapping',	# But can access through lc() and
				# Unicode::UCD 'charinfo'
    'Name',			# But can access through Unicode::UCD
				# 'charinfo' and Name.pl, and inverse through
				# \N{}
    'Numeric_Type',	# But can access through Unicode::UCD 'charinfo', and
			# \p{nt:...} works
    'Numeric_Value',	# But can access through Unicode::UCD 'charinfo'
    'Script',		# But can access through Unicode::UCD 'charscript', and
			# \p{InSCRIPT} works
    'Sentence_Break',	# But \p{sb:...} works

    # For all the 'Simple_...' properties, Perl uses the non-Simple mapping
    # internally, in constructs like lc()
    
    'Simple_Case_Folding',	# But can access through Unicode::UCD 'casefold'
    'Simple_Lowercase_Mapping',	# But can access through Unicode::UCD 'charinfo'
    'Simple_Titlecase_Mapping',	# But can access through Unicode::UCD 'charinfo'
    'Simple_Uppercase_Mapping',	# But can access through Unicode::UCD 'charinfo'

    'Titlecase_Mapping',	# But can access through ucfirst() and
				# Unicode::UCD 'charinfo'
    'Unicode_1_Name',		# But can access through Unicode::UCD 'charinfo'
    'Unicode_Radical_Stroke',	# Unimplemented, but is in CPAN: Unicode::Unihan
    'Uppercase_Mapping',	# But can access through uc() and
				# Unicode::UCD 'charinfo'
    'Word_Break',		# But \p{wb:...} works
);

# Below are files that Unicode furnishes, but this program ignores.

my @ignored_files = (
    'ArabicShaping.txt',	# Unimplemented, but one of the derived
				# properties files gives \p{...} access
    'BidiMirroring.txt',	# For glyph rendering.
    'EastAsianWidth.txt',	# Unimplemented, but one of the derived
				# properties files gives \p{...} access
    'Index.txt',		# An index for UnicodeData.txt
    'LineBreak.txt',		# Unimplemented, but one of the derived
				# properties files gives \p{...} access
    'NamedSequences.txt',	# Unimplemented, but can be accessed through
				# Unicode::UCD 'namedseq'
    'NamedSqProv.txt',		# Not officially part of the Unicode standard
    'NamesList.txt',		# Just adds commentary
    'DNumValues.txt',		# Needs more work in utf8_heavy.pl to enable
    'NormalizationCorrections.txt',	# Data is already in other files.
    'ReadMe.txt',		# Just comments
    'StandardizedVariants.txt',	# Only for glyph changes
);

#######################################################
# Todo: XXX
# More comments
# Add comment to Cn.pl that not functional in perl
# warn on properties that end up handled but are listed as ignored.
# can do more of the add_property_value_name in the Handle props routines
# always fuzzy for prop:value
#
###########################################################

# Generate list of all the files in the directory that could be inputs to this
# program, and delete all those that we know about and don't handle.
my %potential_files;
foreach my $file (glob('*.txt')) {
    $potential_files{$file} = 1;
}
foreach my $file (@ignored_files) {
    delete $potential_files{$file}
}

## "Fuzzy" means this section in Unicode TR18:
##
##    The recommended names for UCD properties and property values are in
##    PropertyAliases.txt [Prop] and PropertyValueAliases.txt
##    [PropValue]. There are both abbreviated names and longer, more
##    descriptive names. It is strongly recommended that both names be
##    recognized, and that loose matching of property names be used,
##    whereby the case distinctions, whitespace, hyphens, and underbar
##    are ignored.

my %BaseNames; ## Names already used for avoiding DOS 8.3 filesystem conflicts
my %Jamo;
my $NameAliases;
my %unhandled_properties;
my %unhandled_property_values;
my %To;

my %aliases;
my %canonical_property_name;
my %canonical_property_value_name;
my %full_property_value_name;
my %input_property_value_name;
my %property_directory;

my $binary_props_dir = 'gc_sc';	# Misnamed, but historical.

## Conceptually, these should really be folded into the 'Table' objects
my %TableInfo;
my %TableDesc;
my %FuzzyNames;
my %AliasInfo;
my %CanonicalToOrig;

##
## Process any args.
##
my $Verbose        = 0;
my $MakeTestScript = 0;
my $AlwaysWrite    = 0;
my $UseDir         = "";
my $FileList       = "$0.lst";
my $MakeList       = 0;
my $GlobList       = 0;

while (@ARGV)
{
    my $arg = shift @ARGV;
    if ($arg eq '-v') {
	$Verbose = 1;
    } elsif ($arg eq '-q') {
	$Verbose = 0;
    } elsif ($arg eq '-w') {
	$AlwaysWrite = 1;	# update the files even if they havent changed
	$FileList = "";
    } elsif ($arg eq '-check') {
	my $this = shift @ARGV;
	my $ok = shift @ARGV;
	if ($this ne $ok) {
	    print "Skipping as check params are not the same.\n";
	    exit(0);
	}
    } elsif ($arg eq '-maketest') {
	print "-maketest option not working now, ignored\n";
	next;
	$MakeTestScript = 1;
    } elsif ($arg eq '-makelist') {
	$MakeList = 1;        
    } elsif ($arg eq '-C' && defined ($UseDir = shift)) {
	-d $UseDir or croak "Unknown directory '$UseDir'";
    } elsif ($arg eq '-L' && defined ($FileList = shift)) {
	print "-L option obsolete, ignored\n";
	next;
	-e $FileList or croak "Filelist '$FileList' doesn't appear to exist!";
    } elsif ($arg eq '-globlist') {
	$GlobList = 1;
    } else {
	#croak "usage: $0 [-v|-q|-w|-C dir|-L filelist] [-globlist] [-maketest] [-makelist]\n",
	croak "usage: $0 [-v|-q|-w|-C dir] [-maketest] [-makelist]\n",
	    "  -v          : Verbose Mode\n",
	    "  -q          : Quiet Mode\n",
	    "  -w          : Write files regardless\n",
	    "  -maketest   : Make test script\n",
	    "  -makelist   : Rewrite the file list based on current setup\n",
	    "  -C dir      : Change to this directory before proceeding\n",
	    "  -check A B  : Executes only if A and B are the same\n";   
    }
}

if ($FileList && ! $GlobList) {
    print "Reading file list '$FileList'\n"
	if $Verbose;
    open my $fh,"<",$FileList or croak "Failed to read '$FileList':$!";
    my @input;
    my @output;
    for my $list ( \@input, \@output ) {
	while (<$fh>) {
	    s/^ \s+ | \s+ $//xg;
	    next if /^ \s* (?: \# .* )? $/x;
	    last if /^ =+ $/x;
	    my ( $file ) = split /\t/, $_;
	    push @$list, $file;
	}
	my %dupe;
	@$list = grep !$dupe{ $_ }++, @$list;
    }
    close $fh;
    croak "No input or output files in '$FileList'!"
	if !@input or !@output;
    if ( $MakeList ) {
	foreach my $file (@output) {
	    unlink $file;
	}
    }            
    if ( $Verbose ) {
	print "Expecting ".scalar( @input )." input files. ",
	      "Checking ".scalar( @output )." output files.\n";
    }
    # we set $youngest to be the youngest input file, including $0 itself.
    my $youngest = -M $0; # do this before the chdir!
    #print __LINE__, ": age of $0 is $youngest\n";
    if ($UseDir) {
	chdir $UseDir or croak "Failed to chdir to '$UseDir':$!";
    }
    foreach my $in (@input) {
	my $age = -M $in;
	croak "Missing input file '$in'" unless defined $age;
	#print __LINE__, ": age of $in is $age, younger than $youngest\n" if $age < $youngest;
	$youngest = $age if $age < $youngest;
    }

    # now we check to see if any output files are older than youngest, if
    # they are we need to continue on, otherwise we can presumably bail.
    my $ok = 1;
    foreach my $out (@output) {
	if ( ! -e $out ) {
	    print "'$out' is missing.\n"
		if $Verbose;
	    $ok = 0;
	    last;
	}
	if ( -M $out > $youngest ) {
	    #print __LINE__, ": $out: age: ", -M $out, ", youngest: $youngest\n";
	    print "'$out' is too old.\n"
		if $Verbose;
	    $ok = 0;
	    last;
	}
    }
    if ($ok) {
	print "Files seem to be ok, not bothering to rebuild.\n";
	exit(0);
    }
    print "Must rebuild tables.\n" if $Verbose;
} elsif ($GlobList) {
    #@input = glob('*.txt'); # Would neet more work
} else {
    if ($Verbose) {
	print "Not checking filelist.\n";
    }
    if ($UseDir) {
	chdir $UseDir or croak "Failed to chdir to '$UseDir':$!";
    }
}

# Input file structure.  This structure gives the 

# Some input files have lines that give default values for code points not
# contained in the file.  Sometimes these should be ignored.
use constant NOT_IGNORED => 1;
use constant IGNORED => 2;


my @input_files = (
    { 'input-file' => 'PropertyAliases.txt',
      'handler' => \&HandlePropertyAliases,
    },
    { 'input-file' => 'PropValueAliases.txt',
      'handler' => \&HandlePropertyValueAliases,
    },
    { 'input-file' => 'DCombiningClass.txt',
      'property' => 'Canonical_Combining_Class',
      'handler' => \&HandleTypicalPropertyFile,
      'post-handler' => \&fill_in_numbers,
      'has-defaults' => NOT_IGNORED,
    },
    { 'input-file' => 'Jamo.txt',
      'handler' => \&HandleJamo,
    },
    { 'input-file' => 'NameAliases.txt',
      'handler' => \&HandleNameAliases,
    },
    { 'input-file' => 'UnicodeData.txt',
      'handler' => \&HandleUnicodeData,
    },
    { 'input-file' => 'DLineBreak.txt',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
      'property' => 'Line_Break',
    },
    { 'input-file' => 'WordBreakProperty.txt',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
      'property' => 'Word_Break',
    },
    { 'input-file' => 'GraphemeBreakProperty.txt',
      'property' => 'Grapheme_Cluster_Break',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
    },
    { 'input-file' => 'SentenceBreakProperty.txt',
      'property' => 'Sentence_Break',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
    },
    { 'input-file' => 'DAge.txt',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
      'post-handler' => \&fill_in_ages,
      'desc' => 'All Assigned Code Points existing in the Unicode Standard: Version',
      'defaults-desc' => 'All Code Points never assigned in the Unicode Standard',
      'property' => 'Age',
      # Currently all prop:pv properties have to be fuzzy 'fuzzy' => 0,
    },
    { 'input-file' => 'DBidiClass.txt',
      'property' => 'Bidi_Class',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
    },
    { 'input-file' => 'DDecompositionType.txt',
      'property' => 'Decomposition_Type',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
    },
    { 'input-file' => 'DEastAsianWidth.txt',
      'property' => 'East_Asian_Width',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
    },
    { 'input-file' => 'DGeneralCategory.txt',
      'property' => 'General_Category',
      'desc' => 'General Category',
      'handler' => \&HandleTypicalPropertyFile,
    },
    { 'input-file' => 'DCoreProperties.txt',
      'handler' => \&HandleTypicalPropertyFile,
    },
    { 'input-file' => 'DBinaryProperties.txt',
      'handler' => \&HandleTypicalPropertyFile,
    },
    { 'input-file' => 'Blocks.txt',
      'handler' => \&HandleTypicalPropertyFile,
      'desc' => 'Block',
      'property' => 'Block',
      'include-property-name' => 1,
      'has-defaults' => NOT_IGNORED,

      # This file comes from Unicode buggy, so use filter to fix it
      'each-line-handler' => \&fix_buggy_blocks_lines,
    },
    { 'input-file' => 'Scripts.txt',
      'property' => 'Script',
      'handler' => \&HandleTypicalPropertyFile,
      'desc' => 'Script',
      'include-property-name' => 1,
      'has-defaults' => NOT_IGNORED,
    },
    { 'input-file' => 'DNormalizationProps.txt',
      'handler' => \&HandleTypicalPropertyFile,

      # This file has various sections, and the only one we currently look at
      # doesn't have defaults.
      'has-defaults' => IGNORED,
    },
    { 'input-file' => 'DJoinGroup.txt',
      'property' => 'Joining_Group',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
    },
    { 'input-file' => 'DJoinType.txt',
      'property' => 'Joining_Type',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
    },
    { 'input-file' => 'DNumType.txt',
      'property' => 'Numeric_Type',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
    },
    #{ 'input-file' => 'DNumValues.txt',
    #  'property' => 'Numeric_Value',
    #  'handler' => \&HandleTypicalPropertyFile,
    #  'each-line-handler' => \&filter_numeric_value_line,
    #  'comment-handler' => \&filter_numeric_value_comment_missing_line,
    #  'has-defaults' => NOT_IGNORED,
    #  'post-handler' => \&fill_in_numbers,
    #  # Currently all prop:pv properties have to be fuzzy 'fuzzy' => 0,
    #},
    { 'input-file' => 'HangulSyllableType.txt',
      'handler' => \&HandleTypicalPropertyFile,
      'has-defaults' => NOT_IGNORED,
      'property' => 'Hangul_Syllable_Type',
    },
    { 'input-file' => 'PropList.txt',
      'handler' => \&HandleTypicalPropertyFile,
      'include-property-name' => 1,
    },
    { 'input-file' => 'CompositionExclusions.txt',
      'handler' => \&HandleTypicalPropertyFile,

      # This file doesn't have the property listed on each line, so use a
      # filter to change it so it does for the rest of the code.
      'each-line-handler' => \&filter_noprop_file,
      'add-property' => 'Composition_Exclusion',
    },
    { 'input-file' => 'CaseFolding.txt',
      'handler' => \&HandleCaseFolding_txt,
    },
    { 'input-file' => 'SpecialCasing.txt',
      'handler' => \&HandleSpecialCasing_txt,
    },
);

my $HEADER=<<"EOF";
# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
# This file is built by $0 from e.g. UnicodeData.txt.
# Any changes made here will be lost!

EOF

my $INTERNAL_ONLY=<<"EOF";
# This file is for internal use by the Perl program only.  The format and even
# the name or existence of this file are subject to change without notice.
# Don't use it directly.

EOF


sub force_unlink {
    my $filename = shift;
    return unless -e $filename;
    return if CORE::unlink($filename);
    # We might need write permission
    chmod 0777, $filename;
    CORE::unlink($filename) or croak "Couldn't unlink $filename: $!\n";
}

##
## Given a filename and a reference to an array of lines,
## write the lines to the file
## Filename can be given as an arrayref of directory names
##
sub Write($\@)
{
    my $file  = shift;
    my $lines = shift;

    if (ref $file) {
	my $pwd = getcwd();
	for (my $i = 0; $i < scalar @$file - 1; $i++) {
	    mkdir $file->[$i], 0755;
	    chdir $file->[$i];
	}
	chdir $pwd;
	$file = File::Spec->catfile(@$file);
    }

    my $TextToWrite = join '', @$lines;
    force_unlink ($file);
    if (not open OUT, ">$file") {
	croak "$0: can't open $file for output: $!\n";
    }
    print "$file written.\n" if $Verbose;

    print OUT $TextToWrite;
    close OUT;
}

##
## The main datastructure (a "Table") represents a set of code points that
## are part of a particular quality (that are part of \pL, \p{InGreek},
## etc.). They are kept as ranges of code points (starting and ending of
## each range).
##
## For example, a range ASCII LETTERS could be represented as:
##   [ [ 0x41 => 0x5A, 'UPPER' ],
##     [ 0x61 => 0x7A, 'LOWER, ] ]
##
sub RANGE_START() { 0 } ## index into range element
sub RANGE_END()   { 1 } ## index into range element
sub RANGE_DATUM()  { 2 } ## index into range element, data assoc w range

# These are properties that are used internally.
my @synthetic_properties = (
    'Is',    # Binary property that goes into the $binary_props_dir directory
    'Perl', # Perl-defined properties; all are binary, but need to be
	    # distinguished from other binary properties for most of the
	    # program
);

sub fuzzy_name($) {
    my $name = shift;
    $name =~ s/\s+//g;
    $name =~ s/(?<=.)[-_]+(?=.)//g; # Get rid of interior dashes and underscores
    return $name;
}

sub Canonicalize($)
{
    # Used to do a lot more, but we now save the property names as input, so
    # this just capitalizes the first letter after making it fuzzy.
    # Maybe should be removed
    # The old stuff: $name =~ s/(?<=[_ -])(.)/\u$1/g;
    return fuzzy_name(ucfirst(shift));
}

sub canonicalize($) {
    return lc fuzzy_name(shift)
}

# Return the canonical property name
sub cpn($) {
    #carp 'cpn';
    my $name = shift;
    return undef unless defined $name;
    return $name unless $name =~ /\D/;	# digits only
    return $name if $name =~ /^-?\d+(\/\d+)?$/;  # Rational number
    my $canonical_name = canonicalize($name);
    return $canonical_name if grep $name eq $_, @synthetic_properties;
    #print __LINE__, ": $canonical_name\n";
    return $conflicting_property_names{$canonical_name} if
				    $conflicting_property_names{$canonical_name};
    return $canonical_property_name{$canonical_name} if defined
				    $canonical_property_name{$canonical_name};
    return undef;
}

# Contain the canonical names of the same name.
my $block;
my $ccc;
my $gc;
my $is = cpn('Is');
my $perl = cpn('Perl');
my $script;

# Return the standard name for a property value.  This is the preferred
# name, for output purposes.
sub spvn($$) {
    my $property = shift;
    my $property_value = shift;
    #return $property_value unless $property_value =~ /\D/;
    #return $property_value if $property_value =~ /^-?\d+(\/\d+)?$/;  # Rational number
    # XXX
    my $name = $input_property_value_name{cpn($property)}{cpvn($property,
							    $property_value)};
    $name = 'In_' . $name if $property eq $block;
    return $name;
}

sub spn($) {
    my $property = shift;
    #print __LINE__, ": $property\n";
    return spvn($is, $property);
}

sub fpvn($$) {
    my $property = shift;
    my $property_value = shift;

    return $property_value unless $property_value =~ /\D/;	# All digits
    return $property_value if $property_value =~ /^-?\d+(\/\d+)?$/;  # Rational number
    $property = cpn($property);
    $property_value = cpvn($property, $property_value);
    my $full = $full_property_value_name{$property}{$property_value};
    return $input_property_value_name{$property}{$full};
}

sub fpn($) {
    my $name = shift;
    return undef unless defined $name;
    return $name unless $name =~ /\D/;	# All digits
    return $name if $name =~ /^-?\d+(\/\d+)?$/;  # Rational number
    my $full = cpn($name);
    return undef unless defined $full;
    return fpvn($is, $full);
}

sub cpvn($$) {
    my $property = shift;
    my $property_value = shift;

    return $property_value unless $property_value =~ /\D/;  # All digits
    return $property_value if $property_value =~ /^-?\d+(\/\d+)?$/;  # Rational number
    my $canonical_property = cpn($property);
    unless (defined $canonical_property) {
	carp "Unknown property name '$property'\n";
	return undef
    }
    return cpn($property_value) if $canonical_property eq $is;
    my $canonical_name = canonicalize($property_value);
    $canonical_name = $canonical_property_value_name{$canonical_property}{$canonical_name};
    return $canonical_name;
}

# This function should be called as the first statement in the loop reading in
# the input of all property files to guarantee common handling.  It changes $_
# to whatever the rest of the loop code should have, setting it to empty if
# no further processing should be done.

sub prepare_line($;$) {
    my $file = shift;
    my $defaults_ref = shift;

    chomp;

    my $defaults;

    # Call any comment handler for this line.
    $file->{'comment-handler'}($file) if $file->{'comment-handler'};

    # See if this line is the comment line that defines what property value 
    # code points not listed in the file should have.  The format or existence
    # of these lines is not guaranteed by Unicode since they are comments, but
    # the documentation says that this was added for machine-readability, so
    # probably won't change.  This works starting in Unicode Version 5.0.  This
    # is an example of such a line:
    #
    # @missing: 0000..10FFFF; Not_Reordered
    #
    # This program currently doesn't handle such lines with more than one
    # field, so ignore any like that.

    if (/$missing_defaults_prefix\s*([^;]*)\s*(?:;\s*([^;]*?)\s*)*/ &&
	! defined $2) {

	# Here there is a defaults line.  Warn if the handler isn't expecting
	# one.  Otherwise get the default if the handler wants it.

	unless ($file->{'has-defaults'}) {
	    carp "Unexpected line '$_' in $file->{'input-file'}.  Assuming no missing entries.";
	} elsif ($file->{'has-defaults'} == NOT_IGNORED) {
	    unless (defined $defaults_ref) {
		croak "File '$file->{'input-file'}' has a defaults line at line number $. which is not to be ignored, but the code needs to accept it.";
	    } else {
		carp "Unexpected multiple defaults lines.  Overwriting earlier one." if defined $$defaults_ref;
		$$defaults_ref = $1;
	    }
	}
    }


    # Remove comments and trailing space, and quit if the result is empty

    s/#.*//;
    s/\s+$//;
    return if /^$/;

    # Call any handler for this line.
    $file->{'each-line-handler'}($file) if $file->{'each-line-handler'};
}


##
## Store the alias definitions for later use.
##

    ##
    ## Most of the work with aliases doesn't occur here,
    ## but rather in utf8_heavy.pl, which uses PVA.pl,

    # Placate the warnings about used only once. (They are used again, but
    # via a typeglob lookup)
    %utf8::PropertyAlias = ();
    %utf8::PA_reverse = ();
    %utf8::PropValueAlias = ();
    %utf8::PVA_reverse = ();
    %utf8::PVA_abbr_map = ();

# This reads in the Property Aliases file, which contains all the properties in
# Unicode and their equivalent aliases.  The fields are separated by white
# space and a semi-colon.  The first field is the preferred abbreviation for
# the property, the second is the full name, and any succeeding ones are other
# accepted names.  Perl uses the preferred abbreviation internally.  The output
# of this routine is ...
#   %utf8::PropertyAlias    A mapping from the lower case canonical name of the
#			short name of a property to the the upper case
#			Canonical full name.
#   %utf8::PA_reverse	A mapping from the canonical form of each alias this
#			property is known by to the upper case Canonical short
#			name of the property.
#   %unhandled_properties   is a list with each key the preferred name for a
#			property in the file.  As later routines handle these
#			properties, they clear the key, and what is left at the
#			end are the properties that weren't handled by the
#			program.   


sub HandlePropertyAliases($$) {
    my $file= shift;
    my $file_handle = shift;
    my @input = <$file_handle>;

    # Add the synthetic properties used internally.
    foreach (@synthetic_properties) {
	push @input, canonicalize($_) . ';' . $_;
    }

    foreach (@input) {
	prepare_line($file);
	next if /^$/;

	my @data = split /\s*;\s*/;

	# Use the full name if the abbreviation conflicts.  Currently it does
	# not handle the case if the full name conflicts, so give up should
	# that happen.
	if ($conflicting_property_names{$data[0]}) {
	    croak "Name of property $data[1] is in conflict" if
				    $conflicting_property_names{$data[1]};

	    # Set up a mapping so that any future occurrences of the abbreviation
	    # will be replaced by the full name (munged).
	    $conflicting_property_names{canonicalize($data[0])} = 
						    canonicalize($data[1]);
	    $data[0] = $data[1];
	}


	# First field is the short name, 2nd is the full one.
	my $abbrev = $data[0];
	my $full_name = $data[1];
	my $fuzzy_abbrev = fuzzy_name($abbrev);
	my $lc_canonical_abbrev =  lc $fuzzy_abbrev;

	# Add to the list of known properties unless it is known not to be
	# handled.  (When later code handles this property, it will remove it,
	# and what's left over at the end of the program are properties that 
	# exist, but aren't handled by the program.  This list should be empty)
	$unhandled_properties{$lc_canonical_abbrev} = 1 unless
	    grep $full_name eq $_, @ignored_properties,
				    @skipped_properties,
				    @synthetic_properties;

	# And save which of the aliases is the full name, so can get back to it.
	$full_property_value_name{$is}{$lc_canonical_abbrev} =
						    canonicalize($full_name);

	# The abbreviation maps to the full name.
	$utf8::PropertyAlias{$lc_canonical_abbrev} = fuzzy_name($full_name)
			    unless grep $full_name eq $_, @synthetic_properties;

	push @{$aliases{$is}{$lc_canonical_abbrev}}, canonicalize($full_name);

	# For every field (alias) on the line ...
	for (my $i = 0; $i < scalar @data; $i++) {

	    # Discard this alias if known to be a problem.
	    next if $conflicting_property_names{$data[$i]};


	    # Each alias maps to the canonical name, which is the abbreviation
	    my $canonical_name = canonicalize($data[$i]);
	    $canonical_property_name{$data[$i]} = $lc_canonical_abbrev;
	    $canonical_property_name{$canonical_name} = $lc_canonical_abbrev;

	    # The output file retains casing (to avoid breaking existing code).
	    # Don't output our internal only properties.
	    $utf8::PA_reverse{$canonical_name} = $fuzzy_abbrev unless
				grep { $full_name eq $_ } @synthetic_properties;

	    # And create a mapping from the canonical form of this alias back
	    # to the input form.  (But not if there is already a mapping, which
	    # can happen if there are two aliases that are equal canonically)
	    $input_property_value_name{$is}{$canonical_name} = $data[$i]
		    unless $input_property_value_name{$is}{$canonical_name};

	    # Add to the list of distinct extra aliases
	    if ($i != 1) {  # The list was initialized above with $data[1]
		next if grep $canonical_name eq $_,
				@{$aliases{$is}{$lc_canonical_abbrev}};
		push @{$aliases{$is}{$lc_canonical_abbrev}}, $canonical_name;
	    }
	}
    }


    # Now that have the data read in, we can set some values that are used
    # frequently later on.
    $block = cpn('Block');
    $ccc = cpn('Canonical_Combining_Class');
    $gc = cpn('General_Category');
    $script = cpn('Script');

    # These properties map to a different directory than their names.
    %property_directory = ( $block => $binary_props_dir,
			    $script => $binary_props_dir,
			    $perl => $binary_props_dir,
			    $gc => $binary_props_dir,
			    $is => $binary_props_dir
			);
}

# a value that that property takes, or 'n/a' if no abbreviation exists; the
# third field is the full name for that property value, and any succeeding
# fields are other accepted names.  Entries for the ccc property have an extra
# field before the abbreviation, which is the equivalent numeric value.  For,
# the ccc property, Perl uses the numeric value internally (since some values
# don't have a name), but otherwise, it uses the abbreviation, if available; or
# the full name if not.  The output of this routine is four hashes.
sub HandlePropertyValueAliases($$) {
    my $file= shift;
    my $file_handle = shift;
    my @input = <$file_handle>;

    # The NaN value is in a weird syntax, commented out in the source file as of
    # Version 5.1, so manually insert a line for it.  But make sure it is
    # still there like it was when this code was written.
    push @input, "nv; n/a; NaN" if grep /$missing_defaults_prefix.*NaN/, @input;

    my $found_lc = 0;
    foreach $_ (@input) {
	#print __LINE__, $_;
	prepare_line($file);
	next if /^$/;

	# backwards compatibility for L& -> LC
	if (/\bCased_Letter\b/) {
	    $_ .= '; L&';
	    $found_lc = 1;
	}

	my ($property_name, @data) = split /\s*;\s*/;

	# Use our canonical version of the main property.
	my $property = cpn($property_name);

	# The full name for the ccc property value is in field 2 of the
	# remaining ones; field 1 for all other properties.
	my $full =  ($property eq $ccc) ? 2 : 1;

	# Normally the preferred name is the short name in the first field, but
	# if there isn't one or if it conflicts, use the full name instead.
	$data[0] = $data[$full] if $data[0] eq "n/a" ||
				    $conflicting_property_names{$data[0]};
	my $abbrev = $data[0];
	my $canonical_abbrev = canonicalize($abbrev);

	# Add to the list of properties that should be handled, but only if the
	# property is not ignored, and the property value is not one that we
	# know won't be in the data
	unless (grep {$_ eq fpn($property) } @ignored_properties) {
	    $unhandled_property_values{$property}{$canonical_abbrev} = 1
		unless $extraneous_property_values{fpn($property)} &&
		    $extraneous_property_values{fpn($property)} eq $data[$full];
	}

	# Create a map from the canonical form of the short name to the full
	# name (with things like underscores squeezed out.)
	$utf8::PropValueAlias{$property}{$canonical_abbrev} =
						    fuzzy_name($data[$full]);
	# For backwards compatibility with any programs that might have been
	# using this in previous incarnations, also create a mapping, but using
	# the original property name
	$utf8::PropValueAlias{$property_name}{$canonical_abbrev} =
						    fuzzy_name($data[$full]);

	# Save which alias is the full name, and put that one first on the list
	# of aliases this property value is known by.
	my $canonical_full = canonicalize($data[$full]);
	$full_property_value_name{$property}{$canonical_abbrev} =
								$canonical_full;
	@{$aliases{$property}{$canonical_abbrev}} = $canonical_full;

	# And create mappings for every alias of the property value
	for (my $i = 0; $i < scalar @data; $i++) {

	    # Certain properties that get moved to the same directory can have
	    # conflicts.  Skip this alias if they are.  Note that block is
	    # also put in that directory, but is handled elsewhere, since its
	    # file names all begin with 'In'
	    next if ($property eq $gc || $property eq $script) &&
					$conflicting_property_names{$data[$i]};

	    # Map the canonical form of this alias to the canonical preferred
	    # form.
	    my $canonical_name = canonicalize($data[$i]);
	    $canonical_property_value_name{$property}{$canonical_name} =
							    $canonical_abbrev;

	    # And a mapping from the canonical name of this alias to the
	    # preferred name.  And in case existing programs use it, the same
	    # but using the main property's input form.
	    $utf8::PVA_reverse{$property}{$canonical_name} = $abbrev;
	    $utf8::PVA_reverse{$property_name}{$canonical_name} = $abbrev;


	    # And create a mapping from the canonical form of this alias back
	    # to the input form.  (But not if there is already a mapping, which
	    # would happen if there are two aliases that are equal canonically)
	    $input_property_value_name{$property}{$canonical_name} = $data[$i]
		unless $input_property_value_name{$property}{$canonical_name};

	    # Add to the list of distinct aliases for this property value.
	    # Field 0 in ccc aliases is a numeric, which we skip for now, and
	    # put at the end.  The full property name was already added before
	    # the loop, so skip it now.
	    if ($i != $full && ($property ne $ccc || $i > 0)) {
		next if grep $canonical_name eq $_,
				@{$aliases{$property}{$canonical_abbrev}};
		push @{$aliases{$property}{$canonical_abbrev}}, $canonical_name
			    if $i== 0 || $canonical_abbrev ne $canonical_name;
	    }
	}

	# For the ccc property, add the numeric name after all the others.
	push @{$aliases{$property}{$canonical_abbrev}}, $canonical_abbrev if $property eq $ccc;

    }

    carp ("Expecting a line for 'Cased_Letter', but didn't find it") unless $found_lc;
}


##
## Associates a property ("Greek", "Lu", "Assigned",...) with a Table.
##
## Called like:
##       New_Prop(Is => 'Greek', $Table, Desc => 'Greek Block', Fuzzy => 1);
##
## Normally, these parameters are set when the Table is created (when the
## Table->New constructor is called), but there are times when it needs to
## be done after-the-fact...)
##
sub New_Prop($$$@)
{
    #print __LINE__, simple_dumper(\@_);
    my $Type = shift;
    my $Name = shift;
    my $Table = shift;

    ## remaining args are optional key/val
    my %Args = @_;

    my $Fuzzy = delete $Args{Fuzzy};
    my $Desc  = delete $Args{Desc}; # description

    ## sanity check a few args
    #print __LINE__, ": $Type\n";
    if ((cpn($Type) eq $is && exists $canonical_property_name{$Name}) ||
	(cpn($Type) ne $is && exists $canonical_property_value_name{$Type}{$Name})) {
	    delete $Args{$Type};
    }

    if (%Args or not ref $Table) {
	confess "$0: bad args to New_Prop"
    }

    if ($TableInfo{$Type}->{$Name}) {
	carp "Existing table for $Type $Name\n";
    } else {
	$TableInfo{$Type}->{$Name} = $Table;
	$TableDesc{$Type}->{$Name} = $Desc;
	if ($Fuzzy) {
	    $FuzzyNames{$Type}->{$Name} = $Name;
	}
    }
}


# Warns if the perl property has a problem.  If it conflicts with a Unicode
# name, there is a problem.  If this is a new perl property, its name should be
# changed to not conflict.  If this is because a new Unicode property conflicts
# with an existing one in perl, add the property to
# %conflicting_property_names, which will cause the Unicode one to be discarded
# (in favor of an alias)

sub warn_if_perl_property_conflict {
    my $Type = shift;
    my $Name = shift;

    $Type = cpn($Type);
    return unless defined $Type;


    $Name = canonicalize($Name);
    confess "Don't use 'In' as the beginning of a property name, because could conflict with a Unicode block now or in the future" if substr($Name, 0, 2) eq 'in';

    confess "A table already exists with this type and name: $Type, $Name" if
			    exists $canonical_property_value_name{$Type}{$Name};
    confess "A table already exists with this name: $Name" if
	    ($Type eq $is || $Type eq $perl) &&
		    ( exists $canonical_property_name{$Name} ||
		    exists $canonical_property_value_name{$gc}{$Name} ||
		    exists $canonical_property_value_name{$script}{$Name}
		    );
}

sub New_Perl_Prop($$$@) {
    my $Name = shift;
    my $Table = shift;

    my $canonical_name = canonicalize($Name);
    warn_if_perl_property_conflict($perl, $canonical_name);

    add_property_value_name($perl, $Name);
    
    return New_Prop($perl, $canonical_name, $Table, @_);
}


##
## Creates a new Table object.
##
## Args are key/value pairs:
##    Is => Name         -- Name of "Is" property to be associated with
##    Fuzzy => Boolean   -- True if name can be accessed "fuzzily"
##    Desc  => String    -- Description of the property
##
## No args are required.
##
sub Table::New
{
    my $class = shift;
    my %Args = @_;
    #print __LINE__, simple_dumper(\%Args);

    my $Table = bless [], $class;

    my $Fuzzy = delete $Args{Fuzzy};
    my $Desc  = delete $Args{Desc};

    #print __LINE__, simple_dumper(\%canonical_property_name);
    my $found = 0;
    for my $Type (keys %canonical_property_name)
    {
	my $Name = delete $Args{$Type};
	if (defined $Name) {
	    New_Prop($Type => $Name, $Table, Desc => $Desc, Fuzzy => $Fuzzy);
	    last;
	}
    }

    ## shouldn't have any left over
    if (%Args) {
	confess "$0: bad args to Table->New"
    }

    return $Table;
}

sub Table::NewPerl
{
    my $class = shift;
    my $name = shift;

    my $canonical_name = canonicalize($name);
    warn_if_perl_property_conflict($perl, $canonical_name);

    add_property_value_name($perl, $name);

    my $Table = Table::New($class, $perl => $canonical_name, @_);
    
    return $Table;
}


# Return the number of ranges in the table
sub Table::RangeCount
{
    my $this = shift;
    return scalar(@$this);
}


##
## Returns the maximum code point currently in the table.
##
sub Table::Max
{
    my $last = $_[0]->[-1];      ## last code point
    return undef unless $last; ## must have code points to have a max
    #confess "oops" unless $last; ## must have code points to have a max
    return $last->[RANGE_END];
}


##
## Returns the minimum code point currently in the table.
##
sub Table::Min
{
    my $first = $_[0]->[0];      ## first code point
    return undef unless $first; ## must have code points to have a min
    return $first->[RANGE_START];
}

##
## Replaces the codepoints in the Table with those in the Table given
## as an arg. (NOTE: this is not a "deep copy").
##
sub Table::Replace($$)
{
    my $Table = shift; #self
    my $New   = shift;

    @$Table = @$New;
}

sub Table::Name ($) {
    my $Table = shift;
    for my $Type (keys %TableInfo) {
	for my $name (keys %{$TableInfo{$Type}}) {
	    my $infoTable   = $TableInfo{$Type}->{$name};
	    next unless defined $infoTable;
	    print __LINE__, ": $Table; $name=$TableInfo{$Type}, $infoTable\n";
	    next unless $Table == $TableInfo{$Type}->{$name};
	    print __LINE__, ": matched $name\n";
	    return ($Type, $name);
	}
    }
    return (undef, undef);
}


# Delete a single code point from a table.

sub Table::Delete($$)
{
    my $Table = shift; #self
    my $codepoint = shift;

    for (my $i = 0; $i < scalar @$Table; $i++) {
	next if $Table->[$i][RANGE_END] < $codepoint;

	# Here the current range ends after the char we want to delete.  If the
	# range also starts after it, it means the code point is not in the
	# table.

	return if $Table->[$i][RANGE_START] > $codepoint;

	# Here the code point is in the range.  If it is the entire range, just
	# delete it.  If it is at one of the ends of the range, simply narrow
	# the range at that end.  But otherwise, the range must be split into
	# two.

	if ($Table->[$i][RANGE_START] == $Table->[$i][RANGE_END]) {
	    splice @$Table, $i, 1;
	} elsif ($Table->[$i][RANGE_START] == $codepoint) {
	    $Table->[$i][RANGE_START]++;
	} elsif ($Table->[$i][RANGE_END] == $codepoint) {
	    $Table->[$i][RANGE_END]--;
	} else {
	    splice @$Table, $i, 1,
				    [	$Table->[$i][RANGE_START],
					$codepoint - 1,
				    	$Table->[$i][RANGE_DATUM]
				    ],
				    [	$codepoint + 1,
				    	$Table->[$i][RANGE_END],
					$Table->[$i][RANGE_DATUM],
				    ];
	}
	return;
    }
}
sub Table::Dump {
    my $Table = shift;
    my $codepoint = shift;

    my @Name = $Table->Name;
    print "Dump of $Name[0]: $Name[1]\n";
    for (my $i = 0; $i < scalar @$Table; $i++) {
       print simple_dumper(\@{$Table->[$i]});
    }
}

sub Table::InsertRange($$$$)
{
    my $Table = shift; #self
    my $start = shift;
    my $end   = shift;
    my $datum  = shift;
    $datum = "" if not defined $datum; ## warning: $datum can be "0"


    # If is at the end of the table, just append it.
    unless (defined $Table->Max && $start <= $Table->Max) {
	$Table->AppendRange($start, $end, $datum);
    } else {


	# Otherwise look through the table for the first element which
	# starts beyond the one being inserted.

	for (my $i = 0; $i < scalar @$Table; $i++) {
	    next if $Table->[$i][RANGE_START] < $start;
	    confess "oops (Table " . $Table->Name . ": New range $start..$end ($datum) splits existing range $Table->[$i-1][RANGE_START]..$Table->[$i-1][RANGE_END] ($Table->[$i-1][RANGE_DATUM])" if $i > 0 && $Table->[$i-1][RANGE_END] >= $start;
	    confess "oops (Table " . $Table->Name . ": New range $start..$end ($datum) splits existing range $Table->[$i][RANGE_START]..$Table->[$i][RANGE_END] ($Table->[$i][RANGE_DATUM])" if $Table->[$i][RANGE_START] <= $end;


	    # If this insertion merely extends the range of the previous and/or
	    # next ranges, change it so it encompasses the appropriate range(s).

	    my $splice_count = 0;   # Assume is a new range which inserts
	    my $splice_start = $i;  # And should insert here.
	    if ($i > 0 &&   # First look at previous range, if any
		$Table->[$i-1][RANGE_DATUM] eq $datum &&	# ? same datum
		$Table->[$i-1][RANGE_END] == $start -1)		# ? adjacent
	    {
		$splice_start = $i - 1;		# will replace previous element
		$splice_count++;
		$start = $Table->[$i-1][RANGE_START];
	    }

	    # Then look at next range.
	    if ($Table->[$i][RANGE_DATUM] eq $datum &&
		$Table->[$i][RANGE_START] == $end +1)
	    {
		$splice_count++;
		$end = $Table->[$i][RANGE_END];
	    }

	    # And splice in the new range, replacing any adjacent ranges that
	    # have the same datum.

	    splice @$Table, $splice_start, $splice_count,
				[   $start,	    # RANGE_START
				    $end,	    # RANGE_END
				    $datum	    # RANGE_DATUM
				];
	    return;
	}

	# If get here, it's because we thought the table ended sooner than it
	# actually does.
	confess "oops (Table " . $Table->Name . ": Table max wrong" . $Table->Max . " in trying to insert new range $start..$end ($datum)";
    }
}

##
## Given a new code point, make the last range of the Table extend to
## include the new (and all intervening) code points.
##
## Takes the time to make sure that the extension is valid.
##
sub Table::Extend
{
    my $Table = shift; #self
    my $codepoint = shift;

    my $PrevMax = $Table->Max;

    confess "oops ($codepoint <= $PrevMax)" if $codepoint <= $PrevMax;

    $Table->ExtendNoCheck($codepoint);
}


##
## Given a new code point, make the last range of the Table extend to
## include the new (and all intervening) code points.
##
## Does NOT check that the extension is valid.  Assumes that the caller
## has already made this check.
##
sub Table::ExtendNoCheck
{
    ## Optmized adding: Assumes $Table and $codepoint as parms
    $_[0]->[-1]->[RANGE_END] = $_[1];
}

##
## Given a code point, blindly append it to the end of the table, not checking
## if it could extend the last range of the table.
##
## NOTE: Code points should be added in strictly ascending numeric order.
##
sub Table::AppendNoMerge
{
    my $Table = shift; #self
    my $code_point = shift;
    my $datum  = shift;
    $datum = "" if not defined $datum; ## warning: $name can be "0"

    push @$Table, [ $code_point,    # RANGE_START
		    $code_point,    # RANGE_END
		    $datum   ];	    # RANGE_DATUM
}

##
## Given a code point (and optional name), add it to the Table.
##
## NOTE: Code points should be added in strictly ascending numeric order.
##
sub Table::Append
{
    my $Table     = shift; #self
    my $codepoint = shift;
    my $datum      = shift;
    $datum = "" if not defined $datum; ## warning: $datum can be "0"

    ##
    ## If we've already got a range working, and this code point is the next
    ## one in line, and if the name is the same, just extend the current range.
    ##
    my $last = $Table->[-1];
    if ($last
	and
	$last->[RANGE_END] == $codepoint - 1
	and
	$last->[RANGE_DATUM] eq $datum)
    {
	$Table->ExtendNoCheck($codepoint);
    }
    else
    {
	$Table->AppendNoMerge($codepoint, $datum);
    }
}

##
## Given a code point range starting value and ending value (and name),
## Add the range to the Table.
##
## NOTE: Code points must be added in strictly ascending numeric order.
##
sub Table::AppendRange
{
    my $Table = shift; #self
    my $start = shift;
    my $end   = shift;
    my $datum  = shift;
    $datum = "" if not defined $datum; ## warning: $datum can be "0"

    $Table->Append($start, $datum);
    $Table->Extend($end) if $end > $start;
}

##
## Return a new Table that represents all code points not in the Table.
##
sub Table::Invert
{
    my $Table = shift; #self

    my $New = Table->New();
    my $max = -1;
    for my $range (@$Table)
    {
	my $start = $range->[RANGE_START];
	my $end   = $range->[RANGE_END];
	if ($start-1 >= $max+1) {
	    $New->AppendRange($max+1, $start-1, "");
	}
	$max = $end;
    }
    if ($max+1 < $LastUnicodeCodepoint) {
	$New->AppendRange($max+1, $LastUnicodeCodepoint);
    }
    return $New;
}

##
## Merges any number of other tables with $self, returning the new table.
## (existing tables are not modified)
##
##
## Args may be Tables, or individual code points (as integers).
##
## Can be called as either a constructor or a method.
##
sub Table::Merge
{
    shift(@_) if not ref $_[0]; ## if called as a constructor, lose the class
    my @Tables = @_;

    ## Accumulate all records from all tables
    my @Records;
    for my $Arg (@Tables)
    {
	#print __LINE__, ": Merge, argument = $Arg\n";
	unless (defined $Arg && $Arg ne "") {
	    confess "$0: bad args to Merge"
	} elsif (ref $Arg) {
	    ## arg is a table -- get its ranges
	    #print __LINE__, ": Merge, argument = ", $Arg->Name, "\n";
	    push @Records, @$Arg;
	} else {
	    ## arg is a codepoint, make a range
	    #print __LINE__, ": Merge, argument = '$Arg'\n";
	    push @Records, [ $Arg, $Arg ]
	}
    }

    ## sort by range start, with longer ranges coming first.
    my ($first, @Rest) = sort {
	($a->[RANGE_START] <=> $b->[RANGE_START])
	  or
	($b->[RANGE_END]   <=> $b->[RANGE_END])
    } @Records;

    my $New = Table->New();

    ## Ensuring the first range is there makes the subsequent loop easier
    $New->AppendRange($first->[RANGE_START],
		      $first->[RANGE_END]);

    ## Fold in records so long as they add new information.
    for my $set (@Rest)
    {
	my $start = $set->[RANGE_START];
	my $end   = $set->[RANGE_END];
	if ($start > $New->Max) {
	    $New->AppendRange($start, $end);
	} elsif ($end > $New->Max) {
	    $New->ExtendNoCheck($end);
	}
    }

    return $New;
}

# Returns a new table which is a copy of the input table
sub Table::Copy() 
{
    shift(@_) if not ref $_[0]; ## if called as a constructor, lose the class
    return Table->Merge(@_);	# Merge already does this.
}

##
## Returns a new table containing the intersection of two tables
## (existing tables are not modified)
##
## Can be called as either a constructor or a method.
##
sub Table::Intersect()
{
    shift(@_) if not ref $_[0]; ## if called as a constructor, lose the class
    my $a = shift;
    return &Table::Intersect($a, @_) if scalar @_ > 1;

    # a & b = !(!a | !b)

    confess "Called with undefined value" unless defined $a && defined $_[0];
    return Table->Merge($a->Invert(), $_[0]->Invert()) ->Invert();
}

##
## Given a filename, write a representation of the Table to a file.
## May have an optional comment as a 2nd arg.
## Optional third argument is a heading to be output before the comment.
## Filename may actually be an arrayref of directories
##
sub Table::Write
{
    my $Table    = shift; #self
    my $filename = shift;
    my $comment  = shift;
    my $heading = shift;

    my @OUT = $HEADER;

    # files in subdirectories are internal-use-only
    push @OUT, $INTERNAL_ONLY if ref $filename;
    push @OUT, $heading if $heading;

    if (defined $comment) {
	$comment =~ s/\s+\Z//;
	$comment =~ s/^/# /gm;
	push @OUT, "#\n$comment\n#\n";
    }
    push @OUT, "return <<'END';\n";

    for my $set (@$Table)
    {
	my $start = $set->[RANGE_START];
	my $end   = $set->[RANGE_END];
	my $datum  = $set->[RANGE_DATUM];

	if ($start == $end) {
	    push @OUT, sprintf "%04X\t\t%s\n", $start, $datum;
	} else {
	    push @OUT, sprintf "%04X\t%04X\t%s\n", $start, $end, $datum;
	}
    }

    push @OUT, "END\n";

    main::Write($filename, @OUT);
}

## This used only for making the test script.
## helper function
sub IsUsable($)
{
    my $code = shift;
    return 0 if $code <= 0x0000;                       ## don't use null
    return 0 if $code >= $LastUnicodeCodepoint;        ## keep in range
    return 0 if ($code >= 0xD800 and $code <= 0xDFFF); ## no surrogates
    return 0 if ($code >= 0xFDD0 and $code <= 0xFDEF); ## utf8.c says no good
    return 0 if (($code & 0xFFFF) == 0xFFFE);          ## utf8.c says no good
    return 0 if (($code & 0xFFFF) == 0xFFFF);          ## utf8.c says no good
    return 1;
}

## Return a code point that's part of the table.
## Returns nothing if the table is empty (or covers only surrogates).
## This used only for making the test script.
sub Table::ValidCode
{
    my $Table = shift; #self
    for my $set (@$Table) {
	return $set->[RANGE_END] if IsUsable($set->[RANGE_END]);
    }
    return ();
}

## Return a code point that's not part of the table
## Returns nothing if the table covers all code points.
## This used only for making the test script.
sub Table::InvalidCode
{
    my $Table = shift; #self

    return 0x1234 if not @$Table;

    for my $set (@$Table)
    {
	if (IsUsable($set->[RANGE_END] + 1))
	{
	    return $set->[RANGE_END] + 1;
	}

	if (IsUsable($set->[RANGE_START] - 1))
	{
	    return $set->[RANGE_START] - 1;
	}
    }
    return ();
}


###########################################################################
###########################################################################
###########################################################################


##
## Called like:
##     New_Alias(Is => 'All', SameAs => 'Any', Fuzzy => 1);
##
## The args must be in that order, although the Fuzzy pair may be omitted.
##
## This creates 'IsAll' as an alias for 'IsAny'
##
sub New_Alias($$$@)
{
# XXX Not working currently
    my $Type   = shift; ## eg "Is"XXX or "In"
    my $Alias  = shift;
    my $SameAs = shift; # expecting "SameAs" -- just ignored
    my $Name   = shift;

    ## remaining args are optional key/val
    my %Args = @_;

    my $Fuzzy = delete $Args{Fuzzy};

    ## sanity check a few args
    if (%Args or (cpn($Type) ne $is and cpn($Type) ne cpn('In')) or $SameAs ne 'SameAs') {
	confess "$0: bad args to New_Alias"
    }

    print __LINE__, ": Calling alias for $Type, $Name\n";
    $Alias = Canonicalize($Alias) if $Fuzzy;

    if (not $TableInfo{$Type}->{$Name})
    {
	my $CName = Canonicalize($Name);
	if ($TableInfo{$Type}->{$CName}) {
	    confess "$0: Use canonical form '$CName' instead of '$Name' for alias.";
	} else {
	    confess "$0: don't have original $Type => $Name to make alias\n";
	}
    }
    if ($TableInfo{$Alias}) {
	confess "$0: already have original $Type => $Alias; can't make alias";
    }
    $AliasInfo{$Type}->{$Name} = $Alias;
    if ($Fuzzy) {
	$FuzzyNames{$Type}->{$Alias} = $Name;
    }

}

## Simple Data::Dumper like. Good enough for our needs. We can't use the real
## thing as we have to run under miniperl
sub simple_dumper ($;$) {
    my $item = shift;
    my $indent = shift;
    $indent = "" unless defined $indent;
    my $new_indent = $indent . (" " x 2);
    my @lines;
    if (ref $item) {
	if (ref $item eq 'ARRAY') {
	    push @lines, $new_indent . "[\n";

	    # No surrounding brackets at top level 
	    foreach my $entry (@$item) {
		push @lines, &simple_dumper ($entry, $new_indent);
	    }
	    push @lines, $new_indent . "],\n";
	} elsif (ref $item eq 'HASH') {

	    # No surrounding braces at top level 
	    push @lines, $new_indent . "{\n" if $indent;

	    # Use numeric sort if both items are strictly numeric; otherwise
	    # alphabetic
	    foreach my $key (sort { ("$a$b" =~ /\D/) ? lc($a) cmp lc($b) : $a <=> $b } keys %$item) {
		push @lines, &simple_dumper($key, $new_indent);
		push @lines, &simple_dumper($item->{$key}, $new_indent), "\n";
	    }
	    push @lines, $new_indent . "},\n" if $indent;
	} elsif (ref $item eq 'Table') {
	    $item->Dump;
	} else {
	    croak "Can't cope with $item";
	}
    } elsif (defined $item) {
	    my $copy = $item;
	    $copy =~ s/([\'\\])/\\$1/gs;
	    push @lines, $new_indent . "'$copy',";
    } else {
	push @lines, "undef,\n";
    }
    return @lines;
}


sub HandleJamo($$)
{
    my $file = shift;
    my $file_handle = shift;

    while (<$file_handle>) {
	prepare_line($file);
	next if /^$/;

	unless (/^([0-9A-Fa-f]+)\s*;\s*([^;]*)$/) {
	    carp_bad_line($file);
	    next;
	}

	# First field is the code point, and the 2nd is its short name.
	#print __LINE__, ": $1: $2\n";
	$Jamo{hex $1} = $2;
	delete $unhandled_property_values{cpn('Jamo_Short_Name')}{$2};
    }

    # And we have handled the property associated with this file.
    delete $unhandled_properties{cpn('Jamo_Short_Name')};
}

## Read in the NameAliases.txt.  It contains other normative names of code
## points not listed in UnicodeData.txt.  This happens when there is an
## error in the name found after the data base was published, but instead of
## changing it, to avoid breaking any code that came to rely on the
## erroneous version, the correct name is added as an alias.

sub HandleNameAliases($$)
{
    my $file = shift;
    my $file_handle = shift;

    $NameAliases = Table->New();

    while (<$file_handle>) {
	prepare_line($file);
	next if /^$/;

	unless (/^([0-9A-Fa-f]+)\s*;\s*([^;]*)$/) {
	    carp_bad_line($file);
	    next;
	}

	# First field is code point in hex (e.g. "0041")
	# Second is character name (e.g. "LATIN CAPITAL LETTER A")
	$NameAliases->AppendNoMerge(hex $1, $2);
    }
}

##
## Process UnicodeData.txt (Categories, etc.)
##
#

sub HandleUnicodeData($$)
{
    my $file = shift;
    my $file_handle = shift;

    my $Deco    = Table->New();
    my $Comb    = Table->New();
    my $Name	= Table->New(); ## all characters, individually by name

    $To{'Upper'} = Table->New();
    $To{'Lower'} = Table->New();
    $To{'Title'} = Table->New();
    $To{'Digit'} = Table->New();

    ## Initialize \p{_CanonDCIJ}.  It is fairly complex...
    my $CanonCDIJ = Table->NewPerl('_CanonDCIJ',
			       Desc  => '(for internal casefolding use)',
			       Fuzzy => 0);
    ## It contains the ASCII 'i' and 'j'....
    $CanonCDIJ->Append(0x0069); # ASCII ord("i")
    $CanonCDIJ->Append(0x006A); # ASCII ord("j")

    ## ...and any character with a decomposition that starts with either of
    ## those code points, but only if the decomposition does not have any
    ## combining character with the "ABOVE" canonical combining class.
    # First, create a convenient hash of code points that have this ccc.
    # In the loop later, we will know immediately if a code point has this or
    # not.
    my %AboveCombiningPoints;
    unless ($TableInfo{$ccc}{cpvn($ccc, 'Above')}) {
	croak "Need to process Canonical Combining Classes before UnicodeData";
    } else {
	foreach my $range (@{$TableInfo{$ccc}{cpvn($ccc, 'Above')}}) {
	    for my $i ($range->[RANGE_START] .. $range->[RANGE_END]) {
		$AboveCombiningPoints{$i} = 1;
	    }
	}
    }


    while (<$file_handle>)
    {
	prepare_line($file);
	next if /^$/;

	my ($hexcode,   ## code point in hex (e.g. "0041")
	    $name,      ## character name (e.g. "LATIN CAPITAL LETTER A")
	    $cat,       ## category (e.g. "Lu")
	    $comb,      ## Canonical combining class (e.g. "230")
	    $bidi,      ## directional category (e.g. "L")
	    $deco,      ## decomposition mapping
	    $decimal,   ## decimal digit value
	    $digit,     ## digit value
	    $number,    ## numeric value
	    $mirrored,  ## mirrored
	    $unicode10, ## name in Unicode 1.0
	    $comment,   ## comment field
	    $upper,     ## uppercase mapping
	    $lower,     ## lowercase mapping
	    $title,     ## titlecase mapping
	    @error,	# Shouldn't happen
	  ) = split(/\s*;\s*/);


	carp "Extra fields ignored in line $. in file $file->{'input-file'}: '$_' \n" if @error;

	# Note that in Unicode 3.2 there will be names like
	# LINE FEED (LF), which probably means that \N{} needs
	# to cope also with LINE FEED and LF.
	#$name = $unicode10 if $name eq '<control>';
	$name = $unicode10 if $name eq '<control>' && $unicode10;

	my $code = hex($hexcode);

	## Used in building \p{_CanonDCIJ}
	if ($deco and $deco =~ m/^006[9A]\b/) {	# 0069 = 'i'; 006A = 'j'
	    ## Need to ensure that all decomposition characters do not have
	    ## a %HexCodeToComb in %AboveCombClasses.
	    my $want = 1;
	    for my $deco_hexcode (split / /, $deco) {
		if (exists $AboveCombiningPoints{hex $deco_hexcode}) {
		    ## one of the decmposition chars has an ABOVE combination
		    ## class, so we're not interested in this one
		    $want = 0;
		    last;
		}
	    }
	    $CanonCDIJ->Append($code) if $want;
	}


	##
	## There are a few pairs of lines like:
	##   AC00;<Hangul Syllable, First>;Lo;0;L;;;;;N;;;;;
	##   D7A3;<Hangul Syllable, Last>;Lo;0;L;;;;;N;;;;;
	## that define ranges.
	##  
	#if ($name =~ /^<(.+), (First|Last)>$/ && $cat ne 'Cn')
	if ($name =~ /^<(.+), (First|Last)>$/)
	{
	    $name = $1;
	    my $type = $2;
	    if ($name !~ /^Hangul Syllable/) {
		# XXX fix for charnames
		if ($type eq 'First') {
		    $Name->Append($code, $name);
		} else { 
		    $Name->Extend($code, $name);
		}
		if ($name =~ /^CJK Ideograph/) {
		    $name = "CJK UNIFIED IDEOGRAPH";
		} elsif ($cat ne 'Co' && $cat ne 'Cs') {
		    carp ("Unexpected code point range $name");
		}
	    } else { # Hangul Syllable

		# These constants were taken from Unicode standard, version
		# 5.1, section 3.12
		my $SBase = 0xAC00;
		my $LBase = 0x1100;
		my $VBase = 0x1161;
		my $TBase = 0x11A7;
		my $SCount = 11172;
		my $LCount = 19;
		my $VCount = 21;
		my $TCount = 28;
		my $NCount = $VCount * $TCount;


		# On the first Hangul line just check that matches.  (The next
		# input line should be the one marking the end of the Hangul
		# syllable range, not currently checked for.)
		if ($type eq 'First') {
		    croak "$0: Unexpected Hangul syllable start = $hexcode" if $code != $SBase;
		    next;
		}

		# Here is the last Hangul line.  Insert into the table the
		# expanded list of names using the generation algorithm from
		# Unicode.
		croak "$0: Unexpected Hangul syllable end = $hexcode" if $code != $SBase + $SCount - 1;
		for (my $S = $SBase; $S < $SBase + $SCount; $S++) {
		    use integer;
		    my $SIndex = $S - $SBase;
		    my $L = $LBase + $SIndex / $NCount;
		    my $V = $VBase + ($SIndex % $NCount) / $TCount;
		    my $T = $TBase + $SIndex % $TCount;
		    #print __LINE__, ": L=$L, V=$V, T=$T\n";
		    $name = "HANGUL SYLLABLE " . $Jamo{$L} . $Jamo{$V};
		    $name .= $Jamo{$T} if $T != $TBase;
		    $Name->Append($S, $name);
		}
	    }
	}
	else
	{
	    ## There are other lines whose name is also algorithmically derivable
	    ## from its code point.  To shorten the output Name file, we make
	    ## these into a range, by deleting the code point from the name,
	    ## and letting the 'Append' do its work.  These lines are distinct in
	    ## the input files because they contain data that differentiates
	    ## them from one another, but this is irrelevant for the name.
	    # Left in for now for possible compatibility problems.
	    #$name =~ s/-$hexcode$//;

	    $Name->Append($code, $name);

	    # Don't use append() because it can consolidate adjacent code
	    # points if they both have the same cased value.
	    $To{Upper}->AppendNoMerge($code, $upper) if $upper;
	    $To{Lower}->AppendNoMerge($code, $lower) if $lower;
	    $To{Title}->AppendNoMerge($code, $title) if $title;

	    $To{Digit}->Append($code, $decimal) if length $decimal;

	    $Comb->Append($code, $comb) if $comb;
	    $Deco->Append($code, $deco) if $deco;
	}
    }



    ##
    ## Now dump the files.
    ##
    

    # First the Name table.

    for my $set (@$NameAliases)		# Temporary code.  Better to insert in middle
    {

	$Name->AppendNoMerge($set->[RANGE_START], $set->[RANGE_DATUM]);
    }

    $Name->Write("Name.pl",
	"A code point may appear more than once in this table.  The more \"correct\" name will be the physically last one (the others were incorrectly published, but remain valid)");


    $Comb->Write("CombiningClass.pl");
    $Deco->Write("Decomposition.pl");
    $To{'Digit'}->Write([ "To", "Digit.pl" ]);
}


# The DerivedAge.txt file is structured differently than the property it
# represents, for compactness.  It actually shows the version code points were
# introduced, but the property is supposed to be if a code point exists in that
# version.

sub fill_in_ages($) {
    my $file = shift;

    my $property = cpn($file->{'property'});
    my $previous;

    # For each of the age tables starting with the 2nd earliest, merge the
    # earliest with it, to get all those code points existing in the 2nd
    # earliest.  Repeat merging the new 2nd earliest with the 3rd earliest to
    # get all those existing in the 3rd earliest, and so on.

    foreach my $table (sort { $a <=> $b } keys %{$TableInfo{$property}}) {
	$TableInfo{$property}->{$table}->Replace($TableInfo{$property}->{$table}->Merge($TableInfo{$property}->{$previous})) if $previous;
	$previous = $table;
    }
}


# The PropertyValueAlias file does not contain entries for numbers that don't
# also have symbolic names.  But these numbers exist, and need to have mappings
# for them.  This handler is called for files that contain such numbers, and
# adds the mappings.

sub fill_in_numbers($) {
    my $file = shift;

    my $property = cpn($file->{'property'});
    foreach my $value (keys %{$TableInfo{$property}}) {
	add_property_value_name($property, $value);
	$utf8::PVA_reverse{$property}{$value} = $value unless
				defined $utf8::PVA_reverse{$property}{$value};
    }
}

sub add_property_value_name($$) {
    my $property = shift;
    my $name = shift;

    my $canonical_name = canonicalize($name);
    push @{$aliases{$property}{$canonical_name}}, $canonical_name unless 
				defined @{$aliases{$property}{$canonical_name}};
    $input_property_value_name{$property}{$canonical_name} = $name unless $input_property_value_name{$property}{$canonical_name};
    $canonical_property_value_name{$property}{$canonical_name} = $canonical_name;
    $full_property_value_name{$property}{$canonical_name} = $canonical_name
	unless defined $full_property_value_name{$property}{$canonical_name};
}


# A file may omit the property it is for on each line.  This filter simply appends it so it looks like the other files to the rest of the code

sub filter_noprop_file($) {
    my $file = shift;

    $_ .= "; " . cpn($file->{'add-property'});
}

sub filter_numeric_value_comment_missing_line($) {
    s/^($missing_defaults_prefix)\s+;/$1/;
}

# utf8_heavy.pl converts real number representing rationals to the equivalent
# rational.  It knows about the following denominators, and if a new one is
# added, utf8_heavy.pl would need to changed to accommodate it.  The following
# is to catch this.
my @known_denominators = ( 2, 3, 4, 5, 6, 8 );


# DNumValues contains lines of a different syntax than the typical property file.
# Filter out the extra columns.

sub filter_numeric_value_line($) {
    my $file = shift;

    # Get rid of extra columns.  If porting to 3.2 would have to instead change
    # the decimals to rationals.
    s/;[^;]+;\s+;/;/;


    # The fraction should end the line.  Remove everything up to the denominator.
    if ((my $fraction = $_) =~ s/^.*\///) {
	carp "Denominator $fraction in rational number is unknown.  Add to list and fix utf8_heavy.pl to handle it.  File $file->{'input-file'} Line $.." if $fraction && ! grep { $fraction eq $_} @known_denominators;
    }
}


# The Blocks.txt file is buggy in that the names of the blocks don't quite match
# the names given in PropertyValueAliases.txt, so this changes them so they
# match.  Blanks and dashes are changed into underscores.

sub fix_buggy_blocks_lines($) {

    #print __LINE__, ": $_\n";
    $_ =~ s/^([^;]*;\s*)//;
    my $prefix = $1;
    $_ =~ s/[ -]/_/g;
    $_ =~ s/_([a-z])/_\u$1/g;	# Capitalize first letter of word
    $_ = $prefix . $_;
    #print __LINE__, ": $_\n";
}

# Output a message about the current input line in file $1 being bad.  
sub carp_bad_line($) {
    my $file = shift;
    carp "Unexpected line '$_' in $file->{'input-file'} at line $..  Ignored.";
}

sub HandleTypicalPropertyFile ($$) {
    my $file = shift;
    my $file_handle = shift;


    # Some files are actually lists of sub-properties, (property value names).
    my $file_property = cpn($file->{'property'});

    # Such a file may not list all the code points, but may have a line in it
    # denoting what the value of the missing code points should be.
    my $default_property =  $file_property &&
			    $file->{'has-defaults'}  &&
			    $file->{'has-defaults'} == NOT_IGNORED;

    my $defaults;
    while (<$file_handle>) {
	prepare_line($file, \$defaults);
	next if /^$/;


	if (/^[^;]*;\s*(\w+)/) {
	    my $prop = $1;
	    if (defined $prop) {
		$prop = fpn($prop);
		if (defined $prop && grep $prop eq $_, @skipped_properties) {
		    delete $unhandled_properties{cpn($prop)};
		    delete $unhandled_property_values{cpn($prop)};
		    next;
		}
	    }
	}

	# The line containing the default property value name for missing
	# entries should be in the comments at the beginning of the file, and
	# so should have been seen by the time we get here.  Warn if we were
	# expecting one and didn't get it.
	if ($default_property && ! defined $defaults) {
	    carp "Did not find a line defining missing entries in $file->{'input-file'}.  Assuming no missing entries";
	    $default_property = 0;
	}

	my $low;
	my $high;
	my $prop;

	# The syntax (after stripping comments and trailing white space is like
	# either of these lines:
	#	    0639..063A    ; Ain
	#	    06A0          ; Ain
	unless (/^([0-9A-Fa-f]+)(?:\.\.([0-9A-Fa-f]+))?\s*;\s*([^;]+)$/) {
	    carp_bad_line($file);
	    next;
	}

	$low = hex $1;
	$high = (defined $2) ? hex $2 : $low;
	$prop = $3;

	#print __LINE__, ": $prop\n";

	my $canonical_prop = (defined $file_property)
			    ? cpvn($file_property, $prop)
			    : cpn($prop);
	delete $unhandled_properties{$canonical_prop};
	unless (defined $file_property) {
	    delete $unhandled_property_values{$canonical_prop};
	} else {
	    delete $unhandled_property_values{$file_property}{$canonical_prop};
	}

	my $type = $file_property || $is;
	#print __LINE__, ": creating TableInfo{$type}->{$canonical_prop}\n" unless $TableInfo{$type}->{$canonical_prop};
		    #print __LINE__, ": $file->{'fuzzy'}\n";
	$TableInfo{$type}{$canonical_prop} ||= Table->New(
		    $type => $canonical_prop,
		    Desc => ($file->{'desc'}) ? ("$file->{'desc'} '$prop'") : "",
		    Fuzzy => (defined $file->{'fuzzy'})
				? $file->{'fuzzy'} 
				: 1);
	$TableInfo{$type}{$canonical_prop}->InsertRange($low, $high,
			    ($file->{'include-property-name'}) ? $prop : "");
    }


    # Finished with the file.  Call any special post-file handler.
    $file->{'post-handler'}($file) if $file->{'post-handler'};


    # If missing code points are to be defaulted, do so.

    if ($default_property) {
	$defaults = cpvn($file_property, $defaults);
	delete $unhandled_property_values{$file_property}{$defaults};
	#print __LINE__, ": $file_property: ; $defaults\n";

	# First find all the code points that aren't missing, by creating a
	# table that is the merge of all the ones so far.
	my $temp = Table->New();
	foreach my $table (keys %{$TableInfo{$file_property}}) {
	    next if $table eq $defaults; # No need to include those that will
					# go into the table of defaulteds.
	    $temp->Replace($temp->Merge($TableInfo{$file_property}{$table}));
	}

	# Then create the defaulteds table, if it doesn't already exist.  Use
	# as the description the special one for defaults, if it exists, or the
	# general one if it exists, or nothing.
	$TableInfo{$file_property}{$defaults} ||= Table->New(
		   $file_property => $defaults,
		   Desc => ($file->{'defaults-desc'})
			    ? ("$file->{'defaults-desc'}")  # Note no $defaults
			    : ($file->{'desc'})
				? "$file->{'desc'} '$defaults'"
				: "",
		    Fuzzy => (defined $file->{'fuzzy'})
				? $file->{'fuzzy'} 
				: 1);

	# And add the complement of all the existing code points.
	$TableInfo{$file_property}{$defaults}->Replace(
	    $TableInfo{$file_property}{$defaults}->Merge($temp->Invert));
    }
}

sub FinishProperties() {

    # This routine depends on the standard names for the general categories
    # being what it thinks they are, like 'Cn'.

    # 'Any' is all code points.  Initialize it at the same time as we
    # initialize the major categories to be the merge of all the category tables.
    # The major categories are the merge of all the general category tables which
    # have the same first letters.

    Table->NewPerl('Any',
		Desc  => "[\\x{0000}-\\x{$LastUnicodeCodepointString}]",
		Fuzzy => 1);
    foreach my $table (keys %{$TableInfo{$gc}}) {
	my $major = substr($table, 0, 1);
	delete $unhandled_property_values{$gc}{$major};
	$TableInfo{$gc}{$major} ||= Table->New(
				 $gc => cpvn($gc, $major),
				 Desc  => "Major Category '" . uc($major) . "'",
				 Fuzzy => 1);
	$TableInfo{$gc}{$major}->Replace(
	    $TableInfo{$gc}{$major}->Merge($TableInfo{$gc}{$table}));
	$TableInfo{$perl}{cpvn($perl, 'Any')}->Replace(
	    $TableInfo{$perl}{cpvn($perl, 'Any')}->Merge($TableInfo{$gc}{$table}));
    }

    carp ("Generated highest code point (" .
	    sprintf("%X", $TableInfo{$perl}{cpvn($perl, 'Any')}->Max) .
	    ") doesn't match expected value $LastUnicodeCodepointString")
	if $TableInfo{$perl}{cpvn($perl, 'Any')}->Max != $LastUnicodeCodepoint;
    croak ("Generated table 'Any' doesn't match all code points") unless
	$TableInfo{$perl}{cpvn($perl, 'Any')}->Min == 0 &&
	$TableInfo{$perl}{cpvn($perl, 'Any')}->RangeCount == 1;
	    

    New_Perl_Prop('All',	# XXX use alias
	     Table->Merge($TableInfo{$perl}{cpvn($perl, 'Any')}),
		Desc  => "[\\x{0000}-\\x{$LastUnicodeCodepointString}]",
		Fuzzy => 1);

    New_Perl_Prop('Assigned',
	     $TableInfo{$gc}{cpvn($gc, 'Cn')}->Invert(),
	     Desc  => "All assigned code points",
	     Fuzzy => 1);

    # LC is Ll, Lu, and Lt.
    # (used to be L& or L_, but PropValueAliases.txt defines it as LC)
    New_Prop($gc => cpn('LC'),
	     Table->Merge($TableInfo{$gc}{cpvn($gc, 'Ll')},
			$TableInfo{$gc}{cpvn($gc, 'Lu')},
			$TableInfo{$gc}{cpvn($gc, 'Lt')}),
	     Desc  => '[\p{Ll}\p{Lu}\p{Lt}]',
	     Fuzzy => 1);
    delete $unhandled_property_values{$gc}{cpvn($gc, 'LC')};


    New_Perl_Prop('_CombAbove',
	     $TableInfo{$ccc}{cpvn($ccc, 'Above')},
	     Desc => '(for internal casefolding use)',
	     Fuzzy => 0);


     # The properties below are needed, but have to be derived ourselves: Unicode
     # doesn't furnish pre-computed ones.

     # From Unicode 5.1: Definition D120: A character C is defined to be cased if
     # and only if C has the Lowercase or Uppercase property or has a
     # General_Category value of Titlecase_Letter.
     # Even though this is a Unicode property, it isn't included in their lists,
     # so make it a perl one.
     
    New_Perl_Prop('_Cased',
	     Table->Merge($TableInfo{$is}{cpn('Lowercase')},
			$TableInfo{$is}{cpn('Uppercase')},
			$TableInfo{$gc}{cpvn($gc, 'Lt')}),
	     Desc  => '[\p{Lowercase}\p{Uppercase}\p{Lt}]',
	     Fuzzy => 1);

    # Unicode 5.1: Definition D121: A character C is defined to be
    # case-ignorable if C has the value MidLetter or the value MidNumLet for
    # the Word_Break property or its General_Category is one of Nonspacing_Mark
    # (Mn), Enclosing_Mark (Me), Format (Cf), Modifier_Letter (Lm), or
    # Modifier_Symbol (Sk).

    my $wb = cpn('Word_Break');
    New_Perl_Prop('_Case_Ignorable',
	     Table->Merge(  
			    $TableInfo{$gc}{cpvn($gc, 'Mn')},
			    $TableInfo{$gc}{cpvn($gc, 'Me')},
			    $TableInfo{$gc}{cpvn($gc, 'Cf')},
			    $TableInfo{$gc}{cpvn($gc, 'Lm')},
			    $TableInfo{$gc}{cpvn($gc, 'Sk')},
			    (exists $TableInfo{$wb}
				?
				    (
				    $TableInfo{$wb}{cpvn($wb, 'MidLetter')},
				    $TableInfo{$wb}{cpvn($wb, 'MidNumLet')},
				    )
				:
				    # In earlier versions of the standard, the
				    # above 2 properties were replaced by just
				    # the following characters.  This is here
				    # in case this routine is run on an early
				    # version.  It is arguable that one should
				    # instead use the code points generated
				    # above instead of these.
				    (
				    0x0027, # APOSTROPHE
				    0x00AD, # SOFT HYPHEN (SHY)
				    0x2019, # RIGHT SINGLE QUOTATION MARK
				    )
			    )
			),
	     Desc  => '(for internal casefolding use)',
	     Fuzzy => 0);

    ## Initialize Perl-generated categories.  Some of these are broken and
    # are expected to be replaced in Perl 5.12 by the Posix ones further down.

    New_Perl_Prop('Alpha',
	     Table->Merge($TableInfo{$gc}{cpvn($gc, 'L')},
			$TableInfo{$gc}{cpvn($gc, 'M')}),
	     Desc => "[[:Alpha:]]",
	     Fuzzy => 1);
    New_Perl_Prop('Alnum',
	     Table->Merge($TableInfo{$perl}{cpvn($perl, 'Alpha')},
			$TableInfo{$gc}{cpvn($gc, 'Nd')}),
	     Desc => "[[:Alnum:]]",
	     Fuzzy => 1);
    New_Perl_Prop('Word',
	     Table->Merge($TableInfo{$perl}{cpvn($perl, 'Alpha')},
			$TableInfo{$gc}{cpvn($gc, 'N')},
			$TableInfo{$gc}{cpvn($gc, 'Pc')}),
	     Desc => "[[:Word:]]",
	     Fuzzy => 1);
    New_Perl_Prop('Blank',
	     Table->Merge(  $TableInfo{$gc}{cpvn($gc, 'Zs')},
			0x0009  # TAB
			),
	     Desc => "[[:Blank:]]",
	     Fuzzy => 1);

    # 200B is Zero Width Space which is for line break control, and was
    # (incorrectly) Zs in early versions of Unicode
    $TableInfo{$perl}{cpvn($perl, 'Blank')}->Delete(0x200B);

    New_Perl_Prop('VertSpace',
	     Table->Merge(  0x000A, # 000A: LINE FEED
			    0x000B, # 000B: VERTICAL TAB
			    0x000C, # 000C: FORM FEED
			    0x000D, # 000D: CARRIAGE RETURN
			    0x0085, # 0085: NEL
			    $TableInfo{$gc}{cpvn($gc, 'Zl')},
			    $TableInfo{$gc}{cpvn($gc, 'Zp')}
			),
	     Desc => '\v',
	     Fuzzy => 1);
    New_Perl_Prop('Space',
	     Table->Merge(  $TableInfo{$perl}{cpvn($perl, 'Blank')},
			    $TableInfo{$perl}{cpvn($perl, 'VertSpace')},
			),
	     Desc => "[[:Space:]]",
	     Fuzzy => 1);
    # Perl's traditional space doesn't include Vertical Tab
    New_Perl_Prop('SpacePerl',
	     Table->Copy($TableInfo{$perl}{cpvn($perl, 'Space')}),
	     Desc => '\s',
	     Fuzzy => 1);
    $TableInfo{$perl}{cpvn($perl, 'SpacePerl')}->Delete(0x000B);

    New_Perl_Prop('HorizSpace',
	     $TableInfo{$perl}{cpvn($perl, 'Blank')},
	     Desc => '\h',
	     Fuzzy => 1);
    New_Perl_Prop('Digit',
	     $TableInfo{$gc}{cpvn($gc, 'Nd')},
	     Desc => "[[:Digit:]]",
	     Fuzzy => 1);
    New_Perl_Prop('Upper',
	     $TableInfo{$gc}{cpvn($gc, 'Lu')},
	     Desc => "[[:Upper:]]",
	     Fuzzy => 1);
    New_Perl_Prop('Lower',
	     $TableInfo{$gc}{cpvn($gc, 'Ll')},
	     Desc => "[[:Lower:]]",
	     Fuzzy => 1);
    New_Perl_Prop('Title',
	     $TableInfo{$gc}{cpvn($gc, 'Lt')},
	     Desc => "[[:Title:]]",
	     Fuzzy => 1);
    New_Perl_Prop('ASCII',
	     $TableInfo{$block}{cpvn($block, 'Basic_Latin')},
	     Desc => "[[:ASCII:]]",
	     Fuzzy => 1);
    New_Perl_Prop('Cntrl',
	     Table->Intersect(
		$TableInfo{$gc}{cpvn($gc, 'C')}, # Is C but without unassigneds
		$TableInfo{$gc}{cpvn($gc, 'Cn')}->Invert(),
		),
	     Desc => "[[:Cntrl:]]",
	     Fuzzy => 1);

    # Graph is	! space && ! (Cc|Cs|Cn)
    New_Perl_Prop('Graph',
	     Table->Intersect(
		$TableInfo{$perl}{cpvn($perl, 'Space')}->Invert(),
		Table->Merge($TableInfo{$gc}{cpvn($gc, 'Cc')},
			    $TableInfo{$gc}{cpvn($gc, 'Cs')},
			    $TableInfo{$gc}{cpvn($gc, 'Cn')})->Invert(),
		),
	     Desc => "[[:Graph:]]",
	     Fuzzy => 1);
    New_Perl_Prop('Print',
	     Table->Merge(  $TableInfo{$perl}{cpvn($perl, 'Space')},
			    $TableInfo{$perl}{cpvn($perl, 'Graph')}),
	     Desc => "[[:Print:]]",
	     Fuzzy => 1);
    New_Perl_Prop('Punct',
	     $TableInfo{$gc}{cpvn($gc, 'P')},
	     Desc => "[[:Punct:]]",
	     Fuzzy => 1);
    New_Perl_Prop('XDigit',
	     $TableInfo{$is}{cpn('ASCII_Hex_Digit')},
	     Desc => "[[:XDigit:]]",
	     Fuzzy => 1);

    # Below are the character mappings as defined in the POSIX standard
    # and in the case of PerlSpace and PerlWord as is defined in the test macros
    # for binary strings. IOW, PerlWord is [A-Za-z_] and PerlSpace is [\f\r\n\t ]
    # This differs from Word and the existing SpacePerl (note the prefix/suffix
    # difference) which is basically the Unicode WhiteSpace without the vertical
    # tab included
    # In all but two cases, these are the same as the ones above, restricted to
    # the ASCII range.

    New_Perl_Prop('PosixAlnum',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Alnum')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Alnum:]]",
	     Fuzzy => 1);
    New_Perl_Prop('PosixAlpha',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Alpha')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Alpha:]]",
	     Fuzzy => 1);
    New_Perl_Prop('PosixBlank',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Blank')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Blank:]]",
	     Fuzzy => 1);
    New_Perl_Prop('PosixCntrl',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Cntrl')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Cntrl:]]",
	     Fuzzy => 1);
    New_Perl_Prop('PosixGraph',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Graph')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Graph:]]",
	     Fuzzy => 1);
    New_Perl_Prop('PosixLower',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Lower')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Lower:]]",
	     Fuzzy => 1);

    # \p{print} includes the controls U+0009 - U+000D
    New_Perl_Prop('PosixPrint',
	     Table->Intersect(	$TableInfo{$gc}{cpvn($gc, 'C')}->Invert(),
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Print:]]",
	     Fuzzy => 1);

    # \p{punct} doesn't include the symbols.
    New_Perl_Prop('PosixPunct',
	     Table->Intersect(	Table->Merge($TableInfo{$gc}{cpvn($gc, 'P')},
					    $TableInfo{$gc}{cpvn($gc, 'S')}),
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Punct:]]",
	     Fuzzy => 1);
    New_Perl_Prop('PosixSpace',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Space')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Space:]]",
	     Fuzzy => 1);
    New_Perl_Prop('PosixUpper',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Upper')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Upper:]]",
	     Fuzzy => 1);
    New_Perl_Prop('PosixDigit',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Digit')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix [[:Digit:]]",
	     Fuzzy => 1);
    New_Perl_Prop('PerlSpace',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'SpacePerl')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix PerlSpace",
	     Fuzzy => 1);
    New_Perl_Prop('PerlWord',
	     Table->Intersect(	$TableInfo{$perl}{cpvn($perl, 'Word')},
				$TableInfo{$perl}{cpvn($perl, 'ASCII')}),
	     Desc => "Posix PerlWord",
	     Fuzzy => 1);
}

##
## These are used in:
##   MakePropTestScript()
##   WriteAllMappings()
## for making the test script.
##
my %FuzzyNameToTest;
my %ExactNameToTest;


## This used only for making the test script
sub GenTests($$$$)
{
    my $FH = shift;
    my $Prop = shift;
    my $MatchCode = shift;
    my $FailCode = shift;

    if (defined $MatchCode) {
	printf $FH qq/Expect(1, "\\x{%04X}", '\\p{$Prop}' );\n/, $MatchCode;
	printf $FH qq/Expect(0, "\\x{%04X}", '\\p{^$Prop}');\n/, $MatchCode;
	printf $FH qq/Expect(0, "\\x{%04X}", '\\P{$Prop}' );\n/, $MatchCode;
	printf $FH qq/Expect(1, "\\x{%04X}", '\\P{^$Prop}');\n/, $MatchCode;
    }
    if (defined $FailCode) {
	printf $FH qq/Expect(0, "\\x{%04X}", '\\p{$Prop}' );\n/, $FailCode;
	printf $FH qq/Expect(1, "\\x{%04X}", '\\p{^$Prop}');\n/, $FailCode;
	printf $FH qq/Expect(1, "\\x{%04X}", '\\P{$Prop}' );\n/, $FailCode;
	printf $FH qq/Expect(0, "\\x{%04X}", '\\P{^$Prop}');\n/, $FailCode;
    }
}

## This used only for making the test script
sub ExpectError($$)
{
    my $FH = shift;
    my $prop = shift;

    print $FH qq/Error('\\p{$prop}');\n/;
    print $FH qq/Error('\\P{$prop}');\n/;
}

## This used only for making the test script
my @GoodSeps = (
	    " ",
	    "-",
	    " \t ",
	    "",
	    "",
	    "_",
	   );
my @BadSeps = (
	   "--",
	   "__",
	   " _",
	   "/"
	  );

## This used only for making the test script
sub RandomlyFuzzifyName($;$)
{
    my $Name = shift;
    my $WantError = shift;  ## if true, make an error

    my @parts;
    for my $part (split /[-\s_]+/, $Name)
    {
	if (@parts) {
	    if ($WantError and rand() < 0.3) {
		push @parts, $BadSeps[rand(@BadSeps)];
		$WantError = 0;
	    } else {
		push @parts, $GoodSeps[rand(@GoodSeps)];
	    }
	}
	my $switch = int rand(4);
	if ($switch == 0) {
	    push @parts, uc $part;
	} elsif ($switch == 1) {
	    push @parts, lc $part;
	} elsif ($switch == 2) {
	    push @parts, ucfirst $part;
	} else {
	    push @parts, $part;
	}
    }
    my $new = join('', @parts);

    if ($WantError) {
	if (rand() >= 0.5) {
	    $new .= $BadSeps[rand(@BadSeps)];
	} else {
	    $new = $BadSeps[rand(@BadSeps)] . $new;
	}
    }
    return $new;
}

## This used only for making the test script
sub MakePropTestScript()
{
    ## this written directly -- it's huge.
    force_unlink ("TestProp.pl");
    if (not open OUT, ">TestProp.pl") {
	croak "$0: TestProp.pl: $!\n";
    }
    print OUT <DATA>;

    while (my ($Name, $Table) = each %ExactNameToTest)
    {
	GenTests(*OUT, $Name, $Table->ValidCode, $Table->InvalidCode);
	ExpectError(*OUT, uc $Name) if uc $Name ne $Name;
	ExpectError(*OUT, lc $Name) if lc $Name ne $Name;
    }


    while (my ($Name, $Table) = each %FuzzyNameToTest)
    {
	my $Orig  = $CanonicalToOrig{$Name};
	my %Names = (
		     $Name => 1,
		     $Orig => 1,
		     RandomlyFuzzifyName($Orig) => 1
		    );

	for my $N (keys %Names) {
	    GenTests(*OUT, $N, $Table->ValidCode, $Table->InvalidCode);
	}

	ExpectError(*OUT, RandomlyFuzzifyName($Orig, 'ERROR'));
    }

    print OUT "Finished();\n";
    close OUT;
}


##
## These are used only in:
##   RegisterFileForName()
##   WriteAllMappings()
##
my %Exact;      ## will become %utf8::Exact;
my %Canonical;  ## will become %utf8::Canonical;
my %CaComment;  ## Comment for %Canonical entry of same key

##
## Given info about a name and a datafile that it should be associated with,
## register that assocation in %Exact and %Canonical.
sub RegisterFileForName($$$$;$)
{
    my $Type     = shift;
    my $Name     = shift;
    my $IsFuzzy  = shift;
    my $filename = shift;
    my $is_alias = shift || 0;

    return unless $property_directory{$Type} &&
		    $property_directory{$Type} eq $binary_props_dir;
    ##
    ## The properties that this routine handles all either match an optional
    ## beginning 'Is' or 'In'.  The 'Is' is understood, as it will be removed
    ## in utf8_heavy when this data is being checked.  The 'In' is for the block
    ## property, and is in the standard name.  But a second record is written
    ## without the "In", if it doesn't conflict with anything already there.
    ## This is why block property records are processed last.

    my $canonical_name = canonicalize($Name);
    my $full_name = fpvn($Type, $canonical_name);
    my $extra_canonical_name;
    if ($Type eq $block) {
	$extra_canonical_name = $canonical_name;
	$canonical_name = "in$canonical_name";
	$full_name = "In_$full_name";
    }
    #print __LINE__, ": type=$Type: name=$canonical_name, file=$filename, full=$full_name\n";

    # Put in abbr_map so as to minimize the changes needed to utf8_heavy.pl
    carp "A file for $Type: $canonical_name already exists" if
			$utf8::PVA_abbr_map{$binary_props_dir}{$canonical_name};
    $utf8::PVA_abbr_map{$binary_props_dir}{$canonical_name} = $filename;
    if (not $IsFuzzy)
    {
	croak "oops[$canonical_name] already used" if $Exact{$canonical_name} && ! $is_alias;
	$Exact{$canonical_name} = $filename;
	$Exact{$extra_canonical_name} = $filename if $extra_canonical_name && ! $Exact{$extra_canonical_name};
    }
    else
    {
	croak "oops[$canonical_name] already used" if $Canonical{$canonical_name} && ! $is_alias;


	#print __LINE__, ": canon full= ", canonicalize($full_name), "length full=", length(canonicalize($full_name)), "length short = ", length($canonical_name), "\n";
	#print __LINE__, ": tr returns ", ((my $dummy = $full_name) =~ tr/A-Z//), "\n";
	# Check for comment before we set canonical because 
	if ((length(canonicalize($full_name)) - length($canonical_name) >= 2) ||
	    (((my $dummy = $full_name) =~ tr/A-Z//) >= 2)) {
	    $CaComment{$extra_canonical_name} = $full_name if $extra_canonical_name && ! $Canonical{$extra_canonical_name};
	    $CaComment{$canonical_name} = $full_name if ! $CaComment{$canonical_name};
	}
	$Canonical{$canonical_name} = $filename;
	$Canonical{$extra_canonical_name} = $filename if $extra_canonical_name && ! $Canonical{$extra_canonical_name};
    }
}

sub construct_filename($$;$) {
    my ($Name, $directory, $Warn) = @_;
    #print __LINE__, ": called construct_filename($Name, $directory)\n";
    $Warn = 0 unless defined $Warn;
    ## 'Is' items lose 'Is' from the basename.

    (my $filename = $Name) =~ s/(?<=.)_(?=.)//g; # Remove interior underscores.
    $filename =~ s/[^\w_]+/_/g;		# eg., "L&" -> "L_"
    substr($filename, 8) = '' if length($filename) > 8;

    ##
    ## Make sure the basename doesn't conflict with something we
    ## might have already written. If we have, say,
    ##     InGreekExtended1
    ##     InGreekExtended2
    ## they become
    ##     InGreekE
    ##     InGreek2
    ##
    my $warned = 0;
    while (my $num = $BaseNames{$directory}{lc $filename}++)
    {
	$num++; ## so basenames with numbers start with '2', which
		## just looks more natural.
	## Want to append $num, but if it'll make the basename longer
	## than 8 characters, pre-truncate $filename so that the result
	## is acceptable.
	my $delta = length($filename) + length($num) - 8;
	if ($delta > 0) {
	    substr($filename, -$delta) = $num;
	} else {
	    $filename .= $num;
	}
	if ($Warn && ! $warned) {
	    $warned = 1;
	    carp("'$Name' conflicts with another name on a filesystem with 8 characters");
	}
    }
    return $filename;
}

##
## Writes the info accumulated in
##
##       %TableInfo;
##       %FuzzyNames;
##       %AliasInfo;
##
##


sub WriteAllMappings()
{
    my @MAP;


    # The properties are written out so as to minimize the problems of having
    # to truncate file names (because needs to work on filesystems with 8
    # character name max.  Also, block properties which normally must begin
    # with    'In' have an extra synonym without the 'In' if there is no
    # conflict.  So these must come last.  First generate 2 lists separating
    # out block from everything else

    my @block_list;
    my @non_block_list;
    foreach my $type (keys %TableInfo) {
	foreach my $name (keys %{$TableInfo{$type}}) {

	    # Keep enough information so can easily find where we are.
	    my %hash = ( 'type' => $type,
			'name' => $name,
	    );
	    if ($type eq $block) {
		push @block_list, \%hash;
	    } else {
		push @non_block_list, \%hash;
	    }
	}
    }

    #my %RawNameToFile; ## a per-$Type cache


    # And process the lists in sorted order, with all the block ones coming last
    # They are sorted by order of the length of the property names (shortest
    # first), and if the lengths are equal, alphabetically.
    #print __LINE__, ': %input_property_value_name', simple_dumper(\%input_property_value_name);
    for my $list (\@non_block_list, \@block_list) {
	for my $property (sort {
			my $cmp = length $a->{'name'} <=> length $b->{'name'};
			$cmp = ($a->{'name'} cmp $b->{'name'}) unless $cmp;
			$cmp
			}
	    @{$list}) {

	    my $canonical_name = $property->{'name'};
	    my $Type = $property->{'type'};
	    my $Table   = $TableInfo{$Type}{$canonical_name};
	    my $IsFuzzy = defined $FuzzyNames{$Type}{$canonical_name};

	    ##
	    ## Construct a nice comment to add to the file, and build data
	    ## for the "./Properties" file along the way.
	    ##
	    my $Comment;
	    {
		my $Desc = $TableDesc{$Type}{$canonical_name} || "";
		## get list of names this table is referenced by
		my @Supported = $canonical_name;
		while (my ($Orig, $Alias) = each %{ $AliasInfo{$Type} })
		{
		    if ($Orig eq $canonical_name) {
			push @Supported, $Alias;
		    }
		}

		my $OrigProp;

		$Comment = "This file supports:\n";
		for my $N (@Supported)
		{
		    my $IsFuzzy = defined $FuzzyNames{$Type}->{$N};

		    # This property may have a number of synonyms.  Put all of
		    # them in a comment, in the order previously determined

		    my @aliases = @{$aliases{$Type}{$canonical_name}};
		    confess "Property $Type:$canonical_name doesn't have any entries in the alias list, and should" unless @aliases;
		    #print __LINE__, ": $Type: $canonical_name", simple_dumper(\@aliases);

		    # Similarly, if this is a property value, the main property
		    # could have synonyms.  Create a list of them in the order
		    # we want to output them, as already set up.
		    my @type_aliases;
		    unless ($property_directory{$Type} &&
			$property_directory{$Type} eq $binary_props_dir) {
			@type_aliases = @{$aliases{$is}{$Type}};
			#print __LINE__, ": ", simple_dumper(\@type_aliases), "\n";
			#print __LINE__, ": ", simple_dumper(\@aliases), "\n";

			# Each time through the loop, we will go to the next
			# main property and property value.  Fill in the arrays
			# so they have the same length.
			if (@type_aliases < @aliases) {
			    push @type_aliases, ($Type) x
						    (@aliases - @type_aliases);
			} elsif (@type_aliases > @aliases) {
			    push @aliases, ($canonical_name) x
						    (@type_aliases - @aliases);
			}
		    }
			#print __LINE__, ": ", simple_dumper(\@type_aliases), "\n";
		    my $Props;
		    for (my $i = 0; $i < @aliases; $i++) {
			my $alias = $aliases[$i];
			my $this_fuzzy = $IsFuzzy;
			#print __LINE__, ": $alias\n";
			$Props .= " or\n" if $Props;
			$Props .= "\t";
			my $this_prop = '\p{';
			if ($property_directory{$Type} &&
			    $property_directory{$Type} eq $binary_props_dir) {

			    $this_prop .= 'In_' if $Type eq $block;
			    $this_prop .= $input_property_value_name{$Type}{$alias};

			    # Can't ignore things when only one character
			    $this_fuzzy = 0 if length $alias == 1;
			} else {
			    $this_prop .= $input_property_value_name{$is}{shift(@type_aliases)} . ": " . $input_property_value_name{$Type}{$alias};
			}
			$this_prop .= '}';
			my $MyDesc = ($N ne $canonical_name)
				    ? "Alias for $OrigProp ($Desc)"
				    : ($Desc)
					? $Desc
					: ($OrigProp)
					    ? $OrigProp
					    : "";
			push @MAP, sprintf("%s %-42s %s\n",
				   $this_fuzzy ? '*' : ' ', $this_prop, $MyDesc);
			$OrigProp = $this_prop if not $OrigProp;
			$Props .= $this_prop;
			if ($this_fuzzy) {
			    $Props .= " (";
			    $Props .= "also " if $this_fuzzy && $i > 0;
			    $Props .= "loosely matched)";
			}
		    }
		    $Comment .= "$Props";
		    $Comment .= "\n";

		}
		if ($Desc) {
		    $Comment .= "\nMeaning: $Desc\n";
		}

	    }
	    ##
	    ## Okay, write the file...
	    ##

	    ## Need an 8.3 safe filename (which means "an 8 safe" $filename)
	    my $subdirectory = $property_directory{$Type} || cpn($Type);
	    my @directory = ( 'lib', $subdirectory );
	    my $filename = construct_filename(
				    Canonicalize(spvn($Type, $canonical_name)),
				    join '/',
				    @directory);
	    $Table->Write([ @directory, "$filename.pl" ], $Comment);

	    ## and register it
	    unless ($property_directory{$Type} &&
		    $property_directory{$Type} eq $binary_props_dir) {;
		carp "A file for $Type: $canonical_name already exists" if
			$utf8::PVA_abbr_map{$subdirectory}{$canonical_name};
		$utf8::PVA_abbr_map{$subdirectory}{$canonical_name} = $filename;
	    } else {
		RegisterFileForName($Type => $canonical_name, $IsFuzzy, $filename);
		#$RawNameToFile{"$Type:$canonical_name"} = $filename;

		# And register all aliases for this property
		for my $alias (@{$aliases{$Type}{$canonical_name}}) {
		    #print __LINE__, ": $alias, $canonical_name\n";
		    RegisterFileForName($Type => $alias, $IsFuzzy, $filename) if
					canonicalize($alias) ne $canonical_name;
		}
	    }

	    if ($IsFuzzy)
	    {
		# XXX Fix.  This is expecting In or Is, and doesn't do In right
		#my $standard_name = spvn($Type, $canonical_name);
		#my $CName = Canonicalize($Type . '_'. $standard_name);
		#$FuzzyNameToTest{$standard_name}  = $Table if !$FuzzyNameToTest{$standard_name};
		#$FuzzyNameToTest{$CName} = $Table if !$FuzzyNameToTest{$CName};
	    } else {
		#$ExactNameToTest{$standard_name} = $Table;
	    }
	}

	## Register alias info
	# XXX update when actually use aliases
    #    for my $Name (sort {length $a <=> length $b} keys %{$AliasInfo{$Type}})
    #    {
    #	my $Alias    = $AliasInfo{$Type}->{$Name};
    #	my $IsFuzzy  = $FuzzyNames{$Type}->{$Alias};
    #	my $filename = $RawNameToFile{$Name};
    #	croak "oops [$Alias]->[$Name]" if not $filename;
    #	RegisterFileForName($Type => ?canonicalize($Alias), $IsFuzzy, $filename);
    #
    #	my $Table = $TableInfo{$Type}->{$Name};
    #	croak "oops" if not $Table;
    #	if ($IsFuzzy)
    #	{
    #	    my $CName = Canonicalize($Type .'_'. $Alias);
    #	    $FuzzyNameToTest{$Alias} = $Table if !$FuzzyNameToTest{$Alias};
    #	    $FuzzyNameToTest{$CName} = $Table if !$FuzzyNameToTest{$CName};
    #	} else {
    #	    $ExactNameToTest{$Alias} = $Table;
    #	}
    #    }
    }


    ##
    ## Write out the property list
    ##
    {
	my @OUT = (
		   "##\n",
		   "## This file created by $0\n",
		   "## List of built-in \\p{...}/\\P{...} properties.\n",
		   "##\n",
		   "## '*' in the first column means the property name may\n",
		   "## be 'fuzzy' (loosely matched) with all white space\n",
		   "## ignored, as well as interior dashes and underscores\n",
		   "##\n",
		   "## The last field is a description of the property.\n",
		   "## Refer to the Unicode Standard if the description is\n",
		   "## empty.\n",
		   "##\n\n",
		   sort { lc substr($a,2) cmp lc substr($b, 2) } @MAP,
		  );
	Write('Properties', @OUT);
    }

    use Text::Tabs ();  ## using this makes the files about half the size

    ## Write Exact.pl
    {
	my @OUT = (
		   $HEADER,
		   "##\n",
		   "## Data in this file used by ../utf8_heavy.pl\n",
		   "##\n\n",
		   "## Mapping from name to filename.pl in ./lib/$binary_props_dir\n",
		   "%utf8::Exact = (\n",
		  );

	for my $Name (sort keys %Exact)
	{
	    my $File = $Exact{$Name};
	    $Name = $Name =~ m/\W/ ? qq/'$Name'/ : " $Name ";
	    my $Text = sprintf("%-15s => %s,\n", $Name, qq/'$File'/);
	    push @OUT, Text::Tabs::unexpand($Text);
	}
	push @OUT, ");\n1;\n";

	Write('Exact.pl', @OUT);
    }

    ## Write Canonical.pl
    {
	my @OUT = (
		   $HEADER,
		   "##\n",
		   "## Data in this file used by ../utf8_heavy.pl\n",
		   "##\n\n",
		   "## Mapping from lc(canonical name) to filename.pl in ./lib/$binary_props_dir\n",
		   "%utf8::Canonical = (\n",
		  );
	my $Trail = ""; ## used just to keep the spacing pretty
	for my $Name (sort keys %Canonical)
	{
	    my $File = $Canonical{$Name};
	    if ($CaComment{$Name}) {
		push @OUT, "\n" if not $Trail;
		push @OUT, " # $CaComment{$Name}\n";
		$Trail = "\n";
	    } else {
		$Trail = "";
	    }
	    $Name = $Name =~ m/\W/ ? qq/'$Name'/ : " $Name ";
	    my $Text = sprintf("  %-41s => %s,\n$Trail", $Name, qq/'$File'/);
	    push @OUT, Text::Tabs::unexpand($Text);
	}
	push @OUT, ");\n1\n";
	Write('Canonical.pl', @OUT);
    }


    my @PVA = $HEADER;
    foreach my $name (qw (PropertyAlias PA_reverse PropValueAlias
			  PVA_reverse PVA_abbr_map)) {
	# Should I really jump through typeglob hoops just to avoid a
	# symbolic reference? (%{"utf8::$name})
	push @PVA, "\n", "\%utf8::$name = (\n",
	    simple_dumper (\%{$utf8::{$name}}), ");\n";
    }
    push @PVA, "1;\n";
    Write("PVA.pl", @PVA);

    MakePropTestScript() if $MakeTestScript;
}


sub HandleSpecialCasing_txt($$)
{
    my $file= shift;
    my $file_handle = shift;
    for my $case (qw(Lower Title Upper)) {
	croak "Need to process UnicodeData before SpecialCasing" unless $To{$case};
    }

    my %CaseInfo;

    #
    # Read in the special cases.
    #


    while (<$file_handle>) {
	prepare_line($file);
	next if /^$/;

	# The syntax (after stripping comments and trailing white space is like
	# 03A3; 03C2; 03A3; 03A3; Final_Sigma;
        my ($code, $lower, $title, $upper, $condition, @error) = split(/\s*;\s*/);

	unless ($code ne "" && ! @error) {
	    print __LINE__, ": @error\n";
	    carp_bad_line($file);
	    next;
	}

        if ($condition) { # not implemented yet
            print "# SKIPPING $_\n" if $Verbose;
            next;
        }

        # Wait until all the special cases have been read since
        # they are not listed in numeric order.
        my $ix = hex($code);
        push @{$CaseInfo{Lower}}, [ $ix, $code, $lower ]
	    unless $code eq $lower;
        push @{$CaseInfo{Title}}, [ $ix, $code, $title ]
	    unless $code eq $title;
        push @{$CaseInfo{Upper}}, [ $ix, $code, $upper ]
	    unless $code eq $upper;
    }

    # Now write out the special cases properties in their code point order.
    # Prepend them to the To/{Upper,Lower,Title}.pl.

    for my $case (qw(Lower Title Upper))
    {
        my $NormalCase = $To{$case};

        my $special = "\n" .
	     "# The key: UTF-8 _bytes_, the value: UTF-8 (speed hack)\n" .
	     "%utf8::ToSpec$case =\n(\n";

        for my $prop (sort { $a->[0] <=> $b->[0] } @{$CaseInfo{$case}}) {
            my ($ix, $code, $to) = @$prop;
            my $tostr =
              join "", map { sprintf "\\x{%s}", $_ } split ' ', $to;
            $special .= sprintf qq["%s" => "$tostr",\n], join("", map { sprintf "\\x%02X", $_ } unpack("U0C*", pack("U", $ix)));
	    # Remove any single-character mappings for
	    # the same character since we are going for
	    # the special casing rules.
	    $NormalCase->Delete(hex $code);
        }
        $special .= ");\n\n";

        $NormalCase->Write(["To","$case.pl"], undef, $special);
    }
}

#
# Read in the case foldings.
#
# We will do full case folding, C + F + I (see CaseFolding.txt).  Note that
# there are no I entries starting with Unicode 3.2, but leaving it in allows
# for backward compatibility.
#
sub HandleCaseFolding_txt($)
{
    my $file= shift;
    my $file_handle = shift;

    my $Fold = Table->New();
    my %Fold;

    while (<$file_handle>) {
	prepare_line($file);
	next if /^$/;

	# The syntax (after stripping comments and trailing white space is like
	# 0051; C; 0071;
	unless (/^([0-9A-Fa-f]+)\s*;\s*([CFIST])\s*;\s*([0-9A-Fa-f]+(?: [0-9A-Fa-f]+)*)\s*;$/) {
	    carp_bad_line($file);
	    next;
	}

	my ($code, $status, $fold) = (hex($1), $2, $3);

	next if $status eq 'S';	# Skip simple case folding
	next if $status eq 'T';	# Skip Turkic case folding

	if ($status eq 'C') { # Common: one-to-one folding
	    # Don't use append() because it can consolidate adjacent code
	    # points if they both have the same fold.
	    $Fold->AppendNoMerge($code, $fold);
	} else { # F: full, or I: dotted uppercase I -> dotless lowercase I
	    $Fold{$code} = $fold;
	}
    }


    #
    # Create the special foldings
    #

    my $special =  "\n" .
	     "#  The key: UTF-8 _bytes_, the value: UTF-8 (speed hack)\n" .
	     "%utf8::ToSpecFold =\n(\n";
    for my $code (sort { $a <=> $b } keys %Fold) {
        my $foldstr =
          join "", map { sprintf "\\x{%s}", $_ } split ' ', $Fold{$code};
        $special .= sprintf qq["%s" => "$foldstr",\n], join("", map { sprintf "\\x%02X", $_ } unpack("U0C*", pack("U", $code)));
    }
    $special .= ");\n\n";

    $Fold->Write([ "To", "Fold.pl" ], undef, $special);
}

## Do it....

foreach my $File (@input_files) {
    my $file = $File->{'input-file'};
    if (! -e $file) {
	print STDERR "Skipping processing input file '$file' because not found\n";
	next;
    }

    print "Processing $file\n" if $Verbose;

    # Open the file, and call its handler with it, then close it.
    if (not open IN, "<", $file) {
	croak "$0: Can't open $file: $!\n";
    }
    &{$File->{'handler'}} ($File, *IN);
    close IN or croak "Can't close $file: $!";

    # And mark the file as being handled.  (If it wasn't in the list, means
    # it was marked as to be ignored)
    carp "Was not expecting $file" unless delete $potential_files{$file};
}

# Finish the table generation.

print "Finishing processing\n" if $Verbose;
FinishProperties();

# And write them all out

WriteAllMappings();


if ( $FileList and $MakeList ) {
    
    print "Updating '$FileList'\n"
        if ($Verbose);
        
    open my $ofh,">",$FileList 
        or croak "Can't write to '$FileList':$!";
    print $ofh <<"EOFHEADER";
#
# mktables.lst -- File list for mktables.
#
#   Autogenerated on @{[scalar localtime]}
#
# - First section is input files
#   (mktables itself is automatically included)
# - Section seperator is /^=+\$/
# - Second section is a list of output files.
# - Lines matching /^\\s*#/ are treated as comments
#   which along with blank lines are ignored.
#

# Input files:

EOFHEADER
    my @input=("version",glob('*.txt'));
    print $ofh "$_\n" for 
        sort(@input),
        "\n=================================\n",
        "# Output files:\n",
        # special files
        "Properties";
        
    
    require File::Find;
    my @output_files;
    File::Find::find({
        no_chdir=>1,
        wanted=>sub {
          if (/\.pl$/) {
            s!^\./!!;
            push @output_files, "$_\n";
          }
        },
    },"."); 
    
    print $ofh sort @output_files;
    print $ofh "\n# ",scalar(@input)," input files\n",
               "# ",scalar(@output_files)+1," output files\n\n",
               "# End list\n";  
    close $ofh 
        or carp "Failed to close $ofh: $!";
    
    print "Filelist has ",scalar(@input)," input files and ",
          scalar(@output_files)+1," output files\n"
        if $Verbose;

    # See that the input files have distinct names
    foreach my $file (@input) {
	construct_filename($file, "", 'warn-if-duplicate');
    }
}

print "\nProperties that are not considered:\n" if %unhandled_properties;
foreach my $property (sort keys %unhandled_properties) {
    print fpn($property), "\n";
}

foreach my $property (sort keys %unhandled_property_values) {
    if (%{$unhandled_property_values{$property}}) {
	print "\nProperty values that are not considered:\n";
	last;
    }
}
foreach my $property (sort keys %unhandled_property_values) {
    foreach my $pvn (sort keys %{$unhandled_property_values{$property}}) {
	print fpn($property), ": ", fpvn($property, $pvn), "\n";
    }
}
print "\nInput files that are not considered:\n" if %potential_files;
foreach my $file (sort keys %potential_files) {
    next if grep { $file eq $_ } @ignored_files;
    print "$file\n";
}
print "All done\n" if $Verbose;
exit(0);

## TRAILING CODE IS USED BY MakePropTestScript()
__DATA__
use strict;
use warnings;

my $Tests = 0;
my $Fails = 0;

sub Expect($$$)
{
    my $Expect = shift;
    my $String = shift;
    my $Regex  = shift;
    my $Line   = (caller)[2];

    $Tests++;
    my $RegObj;
    my $result = eval {
        $RegObj = qr/$Regex/;
        $String =~ $RegObj ? 1 : 0
    };
    
    if (not defined $result) {
        print "couldn't compile /$Regex/ on $0 line $Line: $@\n";
        $Fails++;
    } elsif ($result ^ $Expect) {
        print "bad result (expected $Expect) on $0 line $Line: $@\n";
        $Fails++;
    }
}

sub Error($)
{
    my $Regex  = shift;
    $Tests++;
    if (eval { 'x' =~ qr/$Regex/; 1 }) {
        $Fails++;
        my $Line = (caller)[2];
        print "expected error for /$Regex/ on $0 line $Line: $@\n";
    }
}

sub Finished()
{
   if ($Fails == 0) {
      print "All $Tests tests passed.\n";
      exit(0);
   } else {
      print "$Tests tests, $Fails failed!\n";
      exit(-1);
   }
}
